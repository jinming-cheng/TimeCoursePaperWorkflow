%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% F1000Research is an Open Research publishing platform for scientists, scholars and clinicians offering rapid publication of articles and other research outputs without editorial bias. All articles benefit from transparent peer review and editorial guidance on making all source data openly available.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This template is for all article types; for information on specific article type requirements please visit https://f1000research.com/for-authors/article-guidelines
%
% For more information on the F1000Research publishing model please see:  https://f1000research.com/about

\documentclass[10pt,a4paper]{article}
\usepackage{f1000_styles}

%% Default: numerical citations
\usepackage[numbers]{natbib}

%% Uncomment this lines for superscript citations instead
%\usepackage[super]{natbib}

%% Uncomment these lines for author-year citations instead
% \usepackage[round]{natbib}
% \let\cite\citep


%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % these code lines are added by authors
%                           %

\usepackage{orcidlink}      %%%    added by Jinming   %%%

\newcommand{\code}[1]{{\small\texttt{#1}}}
\newcommand{\pkg}[1]{\textit{#1}}
% \newcommand{\Biocpkg}[1]{\textit{#1}}
% \newcommand{\Rclass}[1]{{\small\texttt{#1}}}

\newcommand{\gene}[1]{\textit{#1}}

% % Allowing the large floats to have some text in those pages.
% \renewcommand{\topfraction}{0.8}
% \renewcommand{\floatpagefraction}{0.75}

%                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\pagestyle{fancy}

\title{Unraveling the timeline of gene expression: a pseudo-temporal trajectory analysis of single-cell RNA sequencing data}
\author[1,2]{Jinming Cheng \orcidlink{0000-0003-3806-4694} } 
\author[1,3,*]{Gordon K. Smyth \orcidlink{0000-0001-9221-2892} }
\author[1,2,4,*]{Yunshun Chen \orcidlink{0000-0003-4911-5653} }

\affil[*]{ Correspondence: smyth@wehi.edu.au, yuchen@wehi.edu.au }
\affil[1]{ Bioinformatics Division, The Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia } 
\affil[2]{ Department of Medical Biology, The University of Melbourne, Parkville, VIC 3010, Australia }
\affil[3]{ School of Mathematics and Statistics, The University of Melbourne, Parkville, VIC 3010, Australia } 
\affil[4]{ ACRF Cancer Biology and Stem Cells Division, The Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia }


\maketitle
\thispagestyle{fancy}

<<style, include=FALSE>>=
knitr::opts_chunk$set(error=FALSE,
                      eval=TRUE, # use FALSE for test
                      prompt=TRUE, 
                      message=FALSE,
                      warning=FALSE,
                      comment=NA)

knitr::opts_chunk$set(fig.width=7, fig.height=7, out.width="100%", fig.align="center", fig.path="Figures/") 
knitr::opts_chunk$set(dpi=300, dev="png", 
                      #dev.args=list(pointsize=15), 
                      cache=FALSE, cache.lazy=FALSE)
options(width=83,digits=3)

options(kableExtra.latex.load_packages = FALSE)

options(timeout=300) # to slove "Timeout of 60 seconds was reached" in download.file 

# replace 'xcolor' with 'color' in the tex file
knitr::knit_hooks$set(document = function(x) {sub('\\usepackage[]{xcolor}', '\\usepackage{color}', x, fixed = TRUE)})
@


<<chunkEval, include=FALSE>>=
eval_download = TRUE
eval_single_sample_Seurat = TRUE
eval_1st_integration = TRUE
eval_prepare_pseudobulk = TRUE
eval_cds = TRUE
eval_save_rdata = TRUE
@


<<load packages, include=FALSE, eval = !eval_1st_integration>>=
library(edgeR) 
library(ggplot2)
library(Seurat)
library(monocle3)
@

~\\
\begin{abstract}
There has been a rapid development in single cell RNA sequencing (scRNA-seq) technologies in recent years. 
Droplet-based single cell platforms such as the 10x Genomics' Chromium system enable gene expression profiling of tens of thousands of cells per sample.
The goal of a typical scRNA-seq analysis is to identify different cell subpopulations and their respective marker genes.
Trajectory analysis can also be used to infer the developmental or differentiation trajectories of cells by ordering them along a putative lineage tree based on their gene expression profiles.
This analysis positions cells and cell clusters along a pseudotime trajectory that represents a biological process such as cell differentiation, development, or disease progression.
Here we demonstrate a time-course analysis to identify genes that are significantly associated with pseudotime.
The article demonstrates a comprehensive workflow for performing trajectory inference and time course analysis on a multi-sample single cell RNA-seq experiment of the mouse mammary gland.
The workflow uses open-source R software packages and covers all steps of the analysis pipeline, including quality control, doublet prediction, normalization, integration, dimension reduction, cell clustering, trajectory inference, and pseudo-bulk time course analysis.
Sample integration and cell clustering follows the \pkg{Seurat} pipeline while the trajectory inference is conducted using the \pkg{monocle3} package.
The pseudo-bulk time course analysis uses the quasi-likelihood framework of \pkg{edgeR}.
\end{abstract}


\section*{\color{f1ROrange}Keywords}

Single cell RNA-seq; mammary gland; trajectory analysis; time course analysis; pseudo-bulk; differential expression analysis

\clearpage
\pagestyle{fancy}

\section*{Introduction}

Single cell RNA sequencing (scRNA-seq) has emerged as a popular technique for transcriptomic profiling of samples at the single cell level.
With droplet-based methods, thousands of cells can be sequenced in parallel using next-generation sequencing platforms \cite{macosko2015DropSeq,klein2015inDrop}.
One of the most widely used droplet-based scRNA-seq technologies is the 10x Genomics Chromium which enables profiling transcriptomes of tens of thousands of cells per sample \cite{zheng2017nc10X}.
A common goal of a scRNA-seq analysis is to investigate cell types and states in heterogeneous tissues.
To achieve this, various pipelines have been developed, such as \pkg{Seurat} \cite{hao2021SeuratV4} and the Bioconductor's OSCA pipeline \cite{amezquita2020orchestrating}.
A typical scRNA-seq data analysis pipeline involves quality control, normalization, dimension reduction, cell clustering, and differential expression analysis. \newline

As the cost of scRNA-seq continues to drop, more experimental studies involve replicate samples.
In a multiple sample single-cell experiment, an integration method is required to investigate all cells across all samples simultaneously.
This ensures that sample and batch effects are appropriately considered in visualizing and clustering cells.
Popular integration methods include the Seurat's anchor-based integration method \cite{hao2021SeuratV4}, Harmony \cite{korsunsky2019fast}, and the MNN \cite{haghverdi2018batch}.\newline

After integration and cell clustering, differential expression analysis is often performed to identify marker genes for each cell cluster.
Various methods have been developed at the single-cell level for finding marker genes \cite{risso2018zinbwave,lun2016scran}.
Recently, the pseudo-bulk method has become increasingly popular due to its superior computational efficiency and its ability to consider biological variation between replicate samples \cite{crowell2020muscat}.\newline

Trajectory inference is another popular downstream analysis that aims to study cell differentiation or cell type development.
Popular software tools to perform trajectory analysis include \pkg{monocle3} \cite{cao2019monocle3} and \pkg{slingshot} \cite{street2018slingshot}.
These methods learn trajectories based on the change of gene expression and order cells along a trajectory to obtain pseudotime \cite{trapnell2014monocle, saelens2019comparison}.
This allows for pseudotime-based time course analysis in single-cell experiments, which is extremely useful for investigating specific biological questions of interest.\newline

Here we present a new single-cell workflow that integrates trajectory analysis and pseudo-bulking to execute a single-cell pseudo time course analysis.
The inputs for this workflow are single-cell count matrices, such as those generated by 10x \pkg{cellranger}.
The single-cell level analysis is performed in \pkg{Seurat}, and the trajectory analysis is conducted using \pkg{monocle3}.
Once the pseudo-bulk samples are created and assigned pseudotime, a time course analysis is conducted in \pkg{edgeR} \cite{mccarthy2012edgeR}.
The analysis pipeline presented in this article can be applied to any scRNA-seq study with replicate samples.
\newline 


\section*{Description of the biological experiment}

The scRNA-seq data used in this workflow consists of five mouse mammary epithelium samples at five different stages: embryonic, early postnatal, pre-puberty, puberty and adult.
The puberty sample is from the study in Pal et al. 2017 \cite{pal2017mouse}, whereas the other samples are from Pal et al. 2021 \cite{pal2021mouse}.
These studies examined the stage-specific single-cell profiles in order to gain insight into the early developmental stages of mammary gland epithelial lineage.
The \pkg{cellranger} count matrix outputs of these five samples are available on the GEO repository as series GSE103275 and GSE164017.


\section*{Data preparation}

\subsection*{Downloading the data}

The \pkg{cellranger} output of each sample consists of three key files: a count matrix in \code{mtx.gz} format, barcode information in \code{tsv.gz} format and feature (or gene) information in \code{tsv.gz} format.\newline
The outputs of the mouse mammary epithelium at embryonic stage (E18.5), post-natal 5 days (P5), 2.5 weeks (Pre-puberty), and 10 weeks (Adult) can be downloaded from \href{https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE164017}{\textbf{GSE164017}} \cite{pal2021mouse}, whereas the output of mouse mammary epithelium at 5 weeks (Puberty) can be downloaded from \href{https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE103275}{\textbf{GSE103275}} \cite{pal2017mouse}. \newline

We first create a \code{data} directory to store all the data files.
<<data dir>>=
data_dir <- "data"
if(!dir.exists(data_dir)){dir.create(data_dir, recursive=TRUE)}
@

<<rds file dir,include=FALSE>>=
rds_res_dir <- "results/rds_files"
if(!dir.exists(rds_res_dir)){dir.create(rds_res_dir, recursive=TRUE)}
@

We then download the barcode and count matrix files of the five samples.
<<barcode and matrix files, include=FALSE>>=
accessions <-c("GSM4994960","GSM4994962","GSM4994963","GSM2759554","GSM4994967")
stages <- c("E18-ME", "Pre-D5-BL6", "Pre-BL6", "5wk-1", "Adult-BL6")
file_suffixes <- c("barcodes.tsv.gz", "matrix.mtx.gz")
@

<<barcode and matrix files pal2021and2017, eval = eval_download>>=
accessions <-c("GSM4994960","GSM4994962","GSM4994963","GSM2759554","GSM4994967")
stages <- c("E18-ME", "Pre-D5-BL6", "Pre-BL6", "5wk-1", "Adult-BL6")
file_suffixes <- c("barcodes.tsv.gz", "matrix.mtx.gz")
for ( i in 1:length(accessions) ) {
  for (file_suffix in file_suffixes) {
    filename <- paste0(accessions[i],"_",stages[i],"-",file_suffix)
    url <- paste0("http://www.ncbi.nlm.nih.gov/geo/download/?acc=",
                  accessions[i],"&","format=file&","file=",filename)
    download.file(url=url,destfile=paste0(data_dir,"/",filename))
  }
}
@

Since the five samples in this workflow are from two separate studies and were processed using different versions of mouse genome, the feature information is slightly different between the two runs. 
Here, we download the feature information of both runs.
The \code{GSM2759554\_5wk-1-genes.tsv.gz} file contains the feature information for the \code{5wk-1} sample, whereas \code{GSE164017\_features.tsv.gz} contains the feature information for the other four samples.
<<featureFiles,  include=FALSE>>=
GSE <- c("GSE164017", "GSM2759554")
feature_filenames <- c("GSE164017_features.tsv.gz",
                       "GSM2759554_5wk-1-genes.tsv.gz")
@

<<feature file pal2021and2017, eval = eval_download>>=
GSE <- c("GSE164017", "GSM2759554")
feature_filenames <- c("GSE164017_features.tsv.gz",
                       "GSM2759554_5wk-1-genes.tsv.gz")
for (i in 1:length(GSE) ) {
  url <- paste0("http://www.ncbi.nlm.nih.gov/geo/download/?acc=",
                GSE[i],"&","format=file&","file=",feature_filenames[i])
  download.file(url=url,destfile=paste0(data_dir,"/",feature_filenames[i]))
}
@

A target information file is created to store all the sample and file information.
<<targets>>=
samples <- c("E18.5-epi", "P5", "Pre-puberty", "Puberty", "Adult")
targets <- data.frame(
    samples=samples,
    stages=stages, 
    accessions=accessions,
    matrix.file = paste0("data/",accessions[1:5],"_",stages[1:5],"-","matrix.mtx.gz"), 
    barcode.file = paste0("data/",accessions[1:5],"_",stages[1:5],"-","barcodes.tsv.gz"), 
    feature.file = paste0("data/",feature_filenames[c(1,1,1,2,1)]))
targets
@

\subsection*{Reading in the data}

The downloaded \pkg{cellranger} outputs of all the samples can be read in one-by-one using the \code{read10X} function in the \pkg{edgeR} package.
First, a \code{DGElist} object is created for each sample, which is then consolidated into a single \code{DGElist} object by merging them altogether.
<<read and merge data>>=
library(edgeR)
dge_all <- list()
for ( i in 1:5 ) {
  y <- read10X(mtx = targets$matrix.file[i], 
      barcodes = targets$barcode.file[i], genes = targets$feature.file[i])
  y$samples$group <- targets$samples[i]
  colnames(y) <- paste0(targets$accessions[i],"-",y$samples$Barcode)
  y$genes$Ensembl_geneid <- rownames(y)
  y$genes <- y$genes[,c("Ensembl_geneid","Symbol")]
  y <- y[!duplicated(y$genes$Symbol),]
  rownames(y) <- y$genes$Symbol
  dge_all[[i]] <- y
}
rm(y)
common.genes <- Reduce(intersect, lapply(dge_all, rownames))
for(i in 1:5) dge_all[[i]] <- dge_all[[i]][common.genes, ]
dge_merged <- do.call("cbind", dge_all)
@

The levels of \code{group} in the sample information data frame are reordered and renamed from the early embryonic stage to the late adult stage.
<<relevel groups>>=
dge_merged$samples$group <- factor(dge_merged$samples$group, levels=samples)
@

The number of genes, the total number of cells, and the number of cells in each sample are shown below.
<<dim of merged data>>=
dim(dge_merged)
table(dge_merged$samples$group)
@


\section*{Single-cell RNA-seq analysis}

\subsection*{Quality control}

Quality control (QC) is essential for single cell RNA-seq data analysis.
Common choices of QC metrics include number of expressed genes or features, library size, and proportion of reads mapped to mitochondrial genes in each cell.
The number of expressed genes and mitochondria read percentage in each cell can be calculated as follows.
<<quality control>>=
dge_merged$samples$num_exp_gene <- colSums(dge_merged$counts>0)
mito_genes <- rownames(dge_merged)[grep("^mt-",rownames(dge_merged))]
dge_merged$samples$mito_percentage <- 
  colSums(dge_merged$counts[mito_genes,])/
  colSums(dge_merged$counts)*100
@

These QC metrics can be visualized in the following scatter plots (Figure 1).
<<set theme and colors for ggplot2>>=
library(ggplot2)
my_theme_ggplot <- theme_classic() + 
  theme(axis.text=element_text(size=12),
        axis.title=element_text(size=15,face="bold"),
        plot.title=element_text(size=15,face="bold",hjust=0.5),
        plot.margin=margin(0.5, 0.5, 0.5, 0.5, "cm"))
my_theme_facet <- 
  theme(strip.background=element_rect(colour="white",fill="white"),
        strip.text=element_text(size=15, face="bold",color="black")) 
my_colors_15 <- c("cornflowerblue", "darkorchid1", "firebrick1", "gold",
                  "greenyellow", "mediumspringgreen", "mediumturquoise",
                  "orange1", "pink", "deeppink3", "violet", "magenta",
                  "goldenrod4", "cyan", "gray90")
@

<< Figure1, fig.cap="Scatter plots of quality control metrics across all the samples. The plots on the left show library size vs number of genes detected, whereas those on the right show library size vs mitochondria read percentage.",fig.height = 2*5*0.8,fig.width=4*2*0.8,out.width="70%">>=
p1 <- ggplot(data = dge_merged$samples,
             aes(x=num_exp_gene, y=lib.size, color = group ) ) + 
      geom_point(size=0.5, show.legend=FALSE) + 
      facet_wrap(group~., ncol=1) + 
      scale_color_manual(values=my_colors_15 ) + 
      labs(x="Number of genes", y="Library size") +
      my_theme_ggplot + my_theme_facet
p2 <- ggplot(data = dge_merged$samples,
             aes(x = mito_percentage, y=lib.size, color = group ) ) + 
      geom_point(size = 0.5, show.legend = FALSE) + 
      facet_wrap(group~., ncol=1) + 
      scale_color_manual(values=my_colors_15) + 
      labs(x="Mito-percentage", y="Library size") +
      my_theme_ggplot + my_theme_facet
patchwork::wrap_plots(p1, p2, ncol=2)
@

Cells with a very low number of genes (< 500), as well as high mitochondria read percentage (> 10\%), are considered of low quality and hence are removed from the analysis.
Cells expressing a large number of genes are also removed as they are likely to be doublets.
Different thresholds are selected for different samples based on the distribution of the number of genes expressed.
Here, we choose 5000, 6000, 6000, 3000, 4000 for E18.5-epi, P5, pre-puberty, puberty and adult samples, respectively.
In this workflow, most of the single-cell analysis is conducted using the \textbf{\pkg{Seurat}} package.
A list of five Seurat objects are first created to store the data after QC.
\newline
<<cell filtering, results='hide',eval=eval_single_sample_Seurat>>=
library(Seurat)
n_genes_max <- c(5000, 6000, 6000, 3000, 4000)
data_seurat <- list()
for (i in 1:5) {
  sel <- dge_merged$samples$group == samples[i]
  y <- dge_merged[, sel]
  data_seurat[[i]] <- CreateSeuratObject( counts=y$counts,
      meta.data=y$samples, min.cells=3, min.features=200,
      project=samples[i] )
  data_seurat[[i]] <- subset( data_seurat[[i]],
      subset = (nFeature_RNA > 500) & (nFeature_RNA < n_genes_max[i]) &
                 (mito_percentage < 10) )
}
names(data_seurat) <- samples
@

\subsection*{Standard Seurat analysis of individual sample}

A standard Seurat analysis is performed for each individual sample.
In particular, the data of each sample is first normalized by the default log normalization method in \code{NormalizeData}. 
The top 2000 highly variable genes are identified by \code{FindVariableFeatures}.
The normalized data of the 2000 highly variable genes are scaled by \code{ScaleData} to have a mean of 0 and a variance of 1. 
The principal component analysis (PCA) dimension reduction is performed on the highly variable genes by \code{RunPCA}. 
Uniform manifold approximation and projection (UMAP) dimension reduction is performed on the first 30 PCs by \code{RunUMAP}.
Cell clustering is performed by \code{FindNeighbors} and \code{FindClusters}.
The cell clustering resolution is set at 0.1, 0.1, 0.2, 0.2 and 0.2 for E18.5-epi, P5, pre-puberty, puberty and adult, respectively.

<<analysis of each sample, results='hide', eval=eval_single_sample_Seurat>>=
data_seurat <- lapply(data_seurat, NormalizeData)
data_seurat <- lapply(data_seurat, FindVariableFeatures, nfeatures=2000)
data_seurat <- lapply(data_seurat, ScaleData)
data_seurat <- lapply(data_seurat, RunPCA, verbose = FALSE)
data_seurat <- lapply(data_seurat, RunUMAP, reduction = "pca", dims = 1:30)
data_seurat <- lapply(data_seurat, FindNeighbors, reduction="pca", dims=1:30)
resolutions <- c(0.1, 0.1, 0.2, 0.2, 0.2)
for(i in 1:5)
    data_seurat[[i]] <- FindClusters(data_seurat[[i]], 
        resolution=resolutions[i], verbose=FALSE)
@

\subsection*{Removing potential doublets and non-epithelial cells}

Although high-throughput droplet-based single-cell technologies can accurately capture individual cells, there are instances where a single droplet may contain two or more cells, which are known as doublets or multiplets.
Here we use the \pkg{scDblFinder} package \cite{germain2021doublet} to further remove potential doublets.
To do that, each Seurat object in the list is first converted into a \code{SingleCellExperiment} object using the \code{as.SingleCellExperiment} function in \pkg{Seurat}.
Then the \code{scDblFinder} function in the \pkg{scDblFinder} package is called to predict potential doublets on each \code{SingleCellExperiment} object.
The \code{scDblFinder} output for each sample is stored in the corresponding Seurat object.
<<doublet detection, results='hide',eval=eval_single_sample_Seurat>>=
library(scDblFinder)
for (i in 1:5) {
  sce <- as.SingleCellExperiment(DietSeurat(data_seurat[[i]], 
      graphs=c("pca","umap")) )
  set.seed(42)
  sce <- scDblFinder(sce)
  data_seurat[[i]]$db_score <- sce$scDblFinder.score
  data_seurat[[i]]$db_type <- factor( sce$scDblFinder.class, 
      levels=c("singlet", "doublet") )
}
@

<<save rds single sample analysis, include=FALSE, eval=eval_single_sample_Seurat>>=
filename_rds = paste0(rds_res_dir,"/","data_seurat",".rds")
saveRDS(data_seurat, file = filename_rds)
@

<<read rds single sample analysis, include=FALSE, eval=!eval_single_sample_Seurat>>=
filename_rds = paste0(rds_res_dir,"/","data_seurat",".rds")
data_seurat = readRDS(filename_rds)
@

The main object of this single-cell experiment is to examine the early developmental stages of the mouse epithelial mammary gland.
Therefore, we focus on epithelial cells for the rest of the analysis.
We use the \gene{Epcam} gene to identify epithelial cell clusters in each sample.
The cell clustering, the expression level of \gene{Epcam} and doublet prediction results of each sample are shown below (Figure 2).
<< Figure2, fig.cap="UMAP visualization of each individual samples. The UMAP plots, in sequence from the top row to the bottom row, correspond to E18.5-epi, P5, Pre-puberty, Puberty, and Adult, respectively. In each row, cells are coloured by cluster on the left, by Epcam expression level in the middle, and by doublet prediction on the right.", fig.height = 16, fig.width=12, out.width="85%">>=
p1 <- lapply(data_seurat,function(x){DimPlot(x, pt.size=0.1, cols=my_colors_15) + 
                ggtitle(x$group[1]) + theme(plot.title=element_text(hjust=0.5))})
p2 <- lapply(data_seurat, FeaturePlot, feature="Epcam", pt.size=0.1)
p3 <- lapply(data_seurat, DimPlot, group.by="db_type", pt.size=0.1, 
             cols=c("gray90", "firebrick1"))
patchwork::wrap_plots(c(p1,p2,p3), nrow=5, byrow=FALSE)
@

By examining the expression level of the \gene{Epcam} gene, we select the following clusters in each sample as the epithelial cell population.
<<epi clusters>>=
epi_clusters <- list(
  "E18.5-epi" = 0,
  "P5" = c(1,3),
  "Pre-puberty" = c(0:2, 5),
  "Puberty" = 0:6,
  "Adult" = 0:3
)
@

Cells that are non-epithelial and those identified as potential doublets by \pkg{scDblFinder} are excluded from the subsequent analysis. 
The cellular barcodes of the remaining epithelial cells from each sample are stored in the list object called \code{epi\_cells}.
The respective number of epithelial cells that are retained for each sample is shown below.
<<epi cell filtering>>=
epi_cells <- list()
for (i in samples) {
  epi_cells[[i]] <- rownames(
    subset(data_seurat[[i]]@meta.data,
      (db_type == "singlet") & (seurat_clusters %in% epi_clusters[[i]])))
}
do.call(c, lapply(epi_cells, length))
@


\section*{Data integration}

\subsection*{Integrating epithelial cells of five samples}

Since we have five individual scRNA-seq samples, conducting an integration analysis is necessary to explore all cells across these samples simultaneously.
In this workflow, we use the anchor-based method in the \pkg{Seurat} package for integration.
A \code{Seurat} object is first created from the merged \code{DGEList} object of epithelial cells using \code{CreateSeuratObject} function without filtering any cells (\code{min.features} is set to 0). 
<<merge epi cells>>=
epi_cells <- do.call(c, epi_cells)
dge_merged_epi <- dge_merged[, epi_cells]
seurat_merged <- CreateSeuratObject(counts = dge_merged_epi$counts,
                      meta.data = dge_merged_epi$samples,
                      min.cells = 3, min.features = 0, project = "mammary_epi")
@

Then the \code{Seurat} object is split into a list of five \code{Seurat} objects, where each object corresponds to one of the five samples. 
For each sample, the log normalization method is applied to normalize the raw count by \code{NormalizeData}, and highly variable genes are identified by \code{FindVariableFeatures}. 
<<split seurat epi>>=
seurat_epi <- SplitObject(seurat_merged, split.by = "group")
seurat_epi <- lapply(seurat_epi, NormalizeData)
seurat_epi <- lapply(seurat_epi, FindVariableFeatures, nfeatures = 2000)
@

The feature genes used for integration are chosen by \code{SelectIntegrationFeatures}, and these genes are used to identify anchors for integration by \code{FindIntegrationAnchors}.
The integration process is performed by \code{IntegrateData} based on the identified anchors. 
<<Seurat integration, results='hide', eval=eval_1st_integration>>=
anchor_features <- SelectIntegrationFeatures(seurat_epi,
                      nfeatures = 2000, verbose = FALSE)
anchors <- FindIntegrationAnchors(seurat_epi, verbose = FALSE,
                      anchor.features = anchor_features)
seurat_int <- IntegrateData(anchors, verbose = FALSE)
@

The integrated data are then scaled to have a mean of 0 and a variance of 1 by \code{ScaleData}. 
PCA is performed on the scaled data using \code{RunPCA}, followed by UMAP using \code{RunUMAP}. 
Cell clusters of the integrated data are identified by using \code{FindNeighbors} and \code{FindClusters}.
<<Seurat integration 2, results='hide', eval=eval_1st_integration>>=
DefaultAssay(seurat_int) <- "integrated"
seurat_int <- ScaleData(seurat_int, verbose = FALSE)
seurat_int <- RunPCA(seurat_int, npcs = 30, verbose = FALSE)
seurat_int <- RunUMAP(seurat_int, reduction = "pca",
                  dims = 1:30, verbose = FALSE)
seurat_int <- FindNeighbors(seurat_int, dims = 1:30, verbose = FALSE)
seurat_int <- FindClusters(seurat_int, resolution = 0.2, verbose = FALSE)
@

<<save rds 1st integration, include=FALSE, eval=eval_1st_integration>>=
filename_rds = paste0(rds_res_dir,"/","seurat_int",".rds")
saveRDS(seurat_int, file = filename_rds)
@

<<read rds 1st integration, include=FALSE, eval=!eval_1st_integration>>=
filename_rds = paste0(rds_res_dir,"/","seurat_int",".rds")
seurat_int = readRDS(filename_rds)
@

UMAP plots are generated to visualize the integration and cell clustering results (Figure 3).
The UMAP plot indicates the presence of three major cell clusters (cluster 0, 1, and 2), which are bridged by intermediate clusters located in between them.
Cells at the later stages largely dominate the three major cell clusters, while cells at the earlier stages are predominantly present in the intermediate clusters in the middle.
<<Figure3, fig.cap="UMAP visualization of the integrated data. Cells are coloured by cluster on the left and by original sample on the right.", fig.height = 5, fig.width=12, out.width="100%">>=
seurat_int$group <- factor(seurat_int$group, levels = samples)
p1 <- DimPlot(seurat_int, pt.size = 0.1, cols = my_colors_15)
p2 <- DimPlot(seurat_int, pt.size = 0.1, group.by = "group", 
          shuffle = TRUE, cols = my_colors_15) + labs(title="")
p1 | p2
@

\subsection*{Cell type identification}

The mammary gland epithelium consists of three major cell types: basal myoepithelial cells, luminal progenitor (LP) cells and mature luminal (ML) cells.
These three major epithelial cell populations have been well studied in the literature.
By examining the classic marker genes of the three cell types, we are able to identify basal, LP and ML cell populations in the integrated data (Figure 4). 
Here we use \gene{Krt14} and \gene{Acta2} for basal, \gene{Csn3} and \gene{Elf5} for LP, and \gene{Prlr} and \gene{Areg} for ML.
We also examine the expression level of \gene{Hmgb2} and \gene{Mki67} as they are typical markers for cycling cells and the expression level of \gene{Igfbp7} and \gene{Fabp4} as they are marker genes for stromal cells.
<<Figure4,  fig.cap="Feature plots of the integrated data. Genes from the top row to the bottom rows are the markers of basal, LP, ML, cycling cells, and stroma, respectively.", fig.width=4*2, fig.height = 3*5, out.width="60%">>=
markers <- c("Krt14", "Acta2", "Csn3","Elf5", "Prlr","Areg", 
             "Hmgb2", "Mki67", "Igfbp7","Fabp4")
DefaultAssay(seurat_int) <- "RNA"
FeaturePlot(seurat_int, order = TRUE, pt.size = 0.1, features = markers, ncol = 2)
@

Based on the feature plots, cluster 1, cluster 2 and cluster 0 represent the basal, LP and ML cell populations, respectively.
Cluster 4 mainly consists of cycling cells, whereas cluster 3 seems to be a luminal intermediate cell cluster expressing both LP and ML markers.
Cluster 5 consists of a few non-epithelial (stromal) cells that have not been filtered out previously.\newline

The number of cells in each cluster for each sample is shown below.
<<table cell number>>=
tab_number <- table(seurat_int$group, seurat_int$seurat_clusters)
tab_number
@

The proportion of cells in each cluster is calculated for each sample to compare the variation in cell composition across different stages.
<<table cell proportion>>=
tab_ratio <- round(100*tab_number/rowSums(tab_number), 2)
tab_ratio <- as.data.frame.matrix(tab_ratio)
tab_ratio
@

The bar plot (Figure 5) shows the proportion of different cell types in samples at different developmental stages. 
Specifically, the proportion of basal cells (purple) demonstrates an ascending trend from E18.5 to pre-puberty stage, after which it declines towards adult stage.
The LP cell proportion (red) rises from E18.5 to puberty stage, followed by a slight dip at adult stage.
Although the proportion of ML cells (blue) is higher at P5 than pre-puberty stage, it shows an overall increasing trend.
Cycling cells (green) constitute the highest proportion at E18.5 stage, but decrease to a smaller proportion at pre-puberty stage, with a slight increase at puberty stage, and subsequently, they reduce to a negligible proportion at adult stage.
The augmented cycling cell proportion at puberty stage aligns with the ductal morphogenesis characteristics of the mammary gland.
The luminal intermediate cell proportion (yellow) displays a decreasing trend from E18.5 stage to adult stage.

<<Figure5, fig.cap="Bar plot of cell proportion of each cluster in each sample.",fig.width = 6, fig.height = 4, out.width="55%">>=
par(mar=c(5, 7, 1, 7), xpd=TRUE)
barplot(t(tab_ratio), col=my_colors_15, xlab="Cell proportion (%)", 
    horiz = TRUE, las=1)
legend("right", inset = c(-0.3,0), legend = 0:5, pch = 15, 
    col=my_colors_15, title="Cluster")
@


\section*{Trajectory analysis with monocle3}

\subsection*{Constructing trajectories and pseudotime}

Many biological processes manifest as a dynamic sequence of alterations in the cellular state, which can be estimated through a "trajectory" analysis.
Such analysis is instrumental in detecting the shifts between different cell identities and modeling gene expression dynamics.
By treating single-cell data as a snapshot of an uninterrupted process, the analysis establishes the sequence of cellular states that forms the process trajectory.
The arrangement of cells along these trajectories can be interpreted as pseudotime.\newline

Here, we use the \pkg{monocle3} package to infer the development trajectory in the mouse mammary gland epithelial cell population.
The Seurat object of the integrated data is first converted into a \code{cell\_data\_set} object to be used in \pkg{monocle3}.
<<prepare cds object, eval=eval_cds>>=
library(monocle3)
cds_obj <- SeuratWrappers::as.cell_data_set(seurat_int)
@

\pkg{monocle3} re-clusters cells to assign them to specific clusters and partitions, which are subsequently leveraged to construct trajectories.
If multiple partitions are used, each partition will represent a distinct trajectory.
The calculation of pseudotime, which indicates the distance between a cell and the starting cell in a trajectory, is conducted during the trajectory learning process.
These are done using the \code{cluster\_cells} and \code{learn\_graph} functions. 
To obtain a single trajectory and avoid a loop structure, both \code{use\_partition} and \code{close\_loop} are turned off in \code{learn\_graph}.

<<cluster cell and learn graph, eval=eval_cds>>=
set.seed(42)
cds_obj <- cluster_cells(cds_obj)
cds_obj <- learn_graph(cds_obj, use_partition=FALSE, close_loop=FALSE)
@

<<save rds cds object, eval=eval_cds, include=FALSE>>=
filename_rds = paste0(rds_res_dir,"/", "cds_obj_final",".rds")
saveRDS(cds_obj, file = filename_rds)
@

<<read rds cds object, eval=!eval_cds, include=FALSE>>=
filename_rds = paste0(rds_res_dir,"/", "cds_obj_final",".rds")
cds_obj = readRDS(filename_rds)
@

\subsection*{Visualizing trajectories and pseudotime}

The \code{plot\_cells} function of \pkg{monocle3} is used to generate a trajectory plot that superimposes the trajectory information onto the UMAP representation of the integrated data.
By adjusting the \code{label\_principal\_points} parameter, the names of roots, leaves, and branch points can be displayed.
Cells in the trajectory UMAP plot (Figure 6) on the left are colored by cell cluster identified in the previous Seurat integration analysis.
\newline

Along the \pkg{monocle3} trajectory analysis, several nodes are identified and marked with black circular dots on the resulting plot, representing key points along the trajectories.
To establish the order of cells and calculate their corresponding pseudotime, it is necessary to select a starting node from among the identified nodes. 
For this analysis, node \code{"Y\_65"} in the basal population (cluster 1) was selected as the starting node, as mammary stem cells are known to be enriched in the basal population and give rise to LP and ML cells in the epithelial lineage \cite{shackleton2006stemcell}.
It should be noted that node numbers may vary depending on the version of monocle3 used.\newline

The cells are then ordered and assigned pseudotime values by the \code{order\_cells} function in \pkg{monocle3}.
The resulting pseudotime information can be visualized on the UMAP plot by using the \code{plot\_cells} function, as demonstrated in the UMAP plot on the right (Figure 6).
<<Figure6, fig.cap="UMAP visualization of trajectory and pseudotime computed by monocle3. Cells are coloured by cluster on the left and by pseudotime on the right.", fig.width=10, fig.height = 4, out.width="100%">>=
p1 <- plot_cells(cds_obj, color_cells_by="seurat_clusters",
                 group_label_size=4, graph_label_size=3,
                 label_cell_groups=FALSE, label_principal_points=TRUE,
                 label_groups_by_cluster=FALSE) + 
      scale_color_manual(values = my_colors_15)
cds_obj <- order_cells(cds_obj, root_pr_nodes="Y_65")
p2 <- plot_cells(cds_obj, color_cells_by="pseudotime",
                 label_groups_by_cluster=FALSE, label_leaves=FALSE,
                 label_branch_points=FALSE)
p1 | p2
@

The \code{pseudotime} function in \pkg{monocle3} allows users to extract the pseudotime values of the cells from a \code{cell\_data\_set} object. 
This information can then be stored in the metadata of the Seurat object for further analysis.
<<obtain pseudotime>>=
seurat_int$pseudotime <- pseudotime(cds_obj)
@


\section*{Psuedo-bulk time course analysis with edgeR}

\subsection*{Constructing pseudo-bulk profiles}

After obtaining the pseudotime of each cell, we proceed to a time course analysis to identify genes that change significantly along the pseudotime time.
Our approach involves creating pseudo-bulk samples using a pseudo-bulking approach and performing an \pkg{edgeR}-style time course analysis.\newline

To create the pseudo-bulk samples, read counts are aggregated for all cells with the same combination of sample and cluster.
The number of cells used to construct each pseudo-bulk sample is added to the sample metadata.
The average pseudotime of all cells in each pseudo-bulk sample is used as the pseudotime for that sample.

<<prepare pseudobulk data, eval= eval_prepare_pseudobulk >>=
y <- dge_merged[, colnames(seurat_int)]
y$samples <- cbind(y$samples[, 1:3], 
  seurat_int@meta.data[, c("seurat_clusters", "pseudotime")])
sample_cluster <- paste0(y$samples$group, "_C", y$samples$seurat_clusters)
avg_pseudotime <- tapply(y$samples$pseudotime, sample_cluster, mean)
cell_number <- table(sample_cluster)
y <- sumTechReps(y, ID = sample_cluster)
y$samples$pseudotime <- avg_pseudotime[colnames(y)]
y$samples$cell_number <- cell_number[colnames(y)]
@

The Entrez gene IDs are added to the gene information.
Genes with no valid Entrez gene IDs are removed from the downstream analysis.
<<obtain Entrez GeneID, eval= eval_prepare_pseudobulk>>=
library(org.Mm.eg.db)
entrez_id <- select(org.Mm.eg.db, keys = y$genes$Symbol,
              columns = c("ENTREZID", "SYMBOL"), keytype = "SYMBOL")
y$genes$ENTREZID <- entrez_id$ENTREZID
y <- y[!is.na(y$genes$ENTREZID), ]
@

The samples are ordered by average pseudotime for the following analysis.
<<order by pseudotime, eval= eval_prepare_pseudobulk>>=
y <- y[, order(y$samples$pseudotime)]
@

<<save pseudobulk, include=FALSE, eval= eval_prepare_pseudobulk>>=
filename_rds <- paste0(rds_res_dir,"/","dge_pseudobulk",".rds")
saveRDS(y, file = filename_rds)
@

<<read pseudobulk, include=FALSE, eval= !eval_prepare_pseudobulk>>=
filename_rds <- paste0(rds_res_dir,"/","dge_pseudobulk",".rds")
y <- readRDS(file = filename_rds)
@


\subsection*{Filtering and normalization}

We now proceed to the standard \pkg{edgeR} analysis pipeline, which starts with filtering and normalization.
The sample information, such as library sizes, average pseudotime and cell numbers, are shown below.
<<sample info pseudobulk>>=
y$samples[, c("lib.size", "pseudotime", "cell_number")]
@

To ensure the reliability of the analysis, it is recommended to remove pseudo-bulk samples that are constructed from a small number of cells. 
We suggest each pseudo-bulk sample should contain at least 30 cells.
In this analysis, we identified seven pseudo-bulk samples that were constructed with less than 30 cells and removed them form the analysis.
<<cell filtering pseudobulk>>=
keep_samples <- y$samples$cell_number > 30
y <- y[, keep_samples]
@

Genes with very low count number are also removed from the analysis.
This is performed by the \code{filterByExpr} function in \pkg{edgeR}.
<<gene filtering pseudobulk>>=
keep_genes <- filterByExpr(y)
y <- y[keep_genes, , keep.lib.sizes=FALSE]
@

The number of genes and samples after filtering are shown below.
<<dim after filtering pseudobulk>>=
dim(y)
@

Normalization is performed by the trimmed mean of M values (TMM) method \cite{robinson2010tmm} implemented in the \code{calcNormFactors} function in \pkg{edgeR}.
<<TMM normalization>>=
y <- calcNormFactors(y)
@

A Multi-dimensional scaling (MDS) plot serves as a valuable diagnostic tool for investigating the relationship among samples.
MDS plots are produced using the \code{plotMDS} function in \pkg{edgeR} (Figure 7).
<<Figure7, fig.cap="Multi-dimensional scaling (MDS) plot of the pseudo-bulk samples labelled by pseudotime. Samples are coloured by origianl cell cluster on the left and by developmental stage on the right.", fig.width = 11, fig.height = 5, out.width="100%">>=
par(mar = c(5.1, 5.1, 2.1, 2.1), mfrow=c(1,2))
cluster <- y$samples$seurat_clusters
group <- y$samples$group
plotMDS(y, labels = round(y$samples$pseudotime, 2),
    xlim=c(-6,4), ylim=c(-3,3), col=my_colors_15[cluster])
legend("topleft", legend=levels(cluster), col=my_colors_15, pch=16)
plotMDS(y, labels = round(y$samples$pseudotime, 2),
    xlim=c(-6,4), ylim=c(-3,3), col=my_colors_15[group])
legend("topleft", legend=levels(group), col=my_colors_15, pch=16)
@

On the MDS plot, pseudo-bulk samples derived from the same cell cluster are close to each other.
The samples are positioned in ascending order of pseudotime from left to right, suggesting a continuous shift in the gene expression profile throughout the pseudotime.

\subsection*{Design matrix}

The aim of a time course experiment is to examine the relationship between gene abundances and time points.
Assuming gene expression changes smoothly over time, we use a natural cubic spline with degrees of freedom of 3 to model gene expression along the pseudotime.
The spline design matrix is generated by \code{ns} function in \pkg{splines}. 
The design matrix is also reformed so that the first column represents the linear trend.
<<construct spline design matrix>>=
t1 <- y$samples$pseudotime
X <- splines::ns(as.numeric(t1),df = 3)
A <- cbind(1,t1,X)
QR <- qr(A)
r <- QR$rank
R_rank <- QR$qr[1:r,1:r]
Z <- t(backsolve(R_rank,t(A),transpose=TRUE))
Z <- Z[,-1]
design <- model.matrix(~ Z)
design
@

\subsection*{Dispersion estimation}

The \pkg{edgeR} package uses negative binomial (NB) distribution to model read counts of each gene across all the sample. 
The NB dispersions are estimated by the \code{estimateDisp} function.
The estimated common, trended and gene-specific dispersions can be visualized by \code{plotBCV} (Figure 8).
<<Figure8, fig.cap="A scatter plot of the biological coefficient of variation (BCV) against the average abundance of each gene. The square-root estimates of the common, trended and gene-wise NB dispersions are shown.", fig.width = 5, fig.height = 4.5, out.width="55%">>=
y <- estimateDisp(y, design)
sqrt(y$common.dispersion)
plotBCV(y)
@

The NB model can be extended with quasi-likelihood (QL) methods to account for gene-specific variability from both biological and technical sources \cite{lund2012quasiseq, chen2016edgeR}.
Note that only the trended NB dispersion is used in the QL method. 
The gene-specific variability is captured by the QL dispersion.\newline

The \code{glmQLFit} function is used to fit a QL model and estimate QL dispersions.
The QL dispersion estimates can be visualized by \code{plotQLDisp} (Figure 9).
<<Figure9, fig.cap="A scatter plot of the quarter-root QL dispersion against the average abundance of each gene. Estimates are shown for the raw, trended and squeezed dispersions.", fig.width=5, fig.height = 4.5, out.width="55%">>=
fit <- glmQLFit(y, design, robust=TRUE)
plotQLDisp(fit)
@

\subsection*{Time course trend analysis}

The QL F-tests are performed by \code{glmQLFTest} in \pkg{edgeR} to identify genes that change significantly along the pseudotime.
The test are conducted on all three covariates of the spline model matrix.
This is because the significance of any of the three coefficients would indicate a strong correlation between gene expression and pseudotime.
<<F test>>=
res <- glmQLFTest(fit, coef=2:4)
@

The number of genes significantly associated with pseudotime (FDR < 0.05) are shown below.
<<DE gene number>>=
summary(decideTests(res))
@

Top significant genes can be viewed by \code{topTags}. 
<<all DE genes>>=
topTags(res, n=10L) 
@

The \code{logFC.Z1}, \code{logFC.Z2}, and \code{logFC.Z3} values in the table above denote the estimated coefficients of Z1, Z2, and Z3 for each gene.
It should be noted that these values do not carry the same interpretation as log-fold changes in traditional RNA-seq differential expression analysis.
For each gene, the sign of the coefficient \code{logFC.Z1} indicates whether the expression level of that gene increases or decreases along pseudotime in general.
The top increasing and the top decreasing genes are listed below.
<<top DE genes>>=
tab <- topTags(res, n=Inf)$table
tab$trend <- ifelse(tab$logFC.Z1 > 0, "Up", "Down")
tab.up <- tab[tab$trend == "Up", ]
tab.down <- tab[tab$trend == "Down", ]
head(tab.up)
head(tab.down)
@

Scatter plots are produced to visualize the relationship between gene expression level and pseudotime for the top 3 increasing and the top 3 decreasing genes (Figure 10).
Each point in the scatter plot indicates the observed \code{logCPM} of a pseudo-bulk sample at its average pseudotime. 
A smooth curve is drawn along pseudotime for each gene using the fitted \code{logCPM} values obtained from the spline model.
The \code{cpm} function in \pkg{edgeR} is used to calculate the observed and fitted \code{logCPM}.
Since there is a \code{cpm} function in the \pkg{SingleCellExperiment} package, we use \code{edgeR::cpm} to explicitly call the \code{cpm} function in \pkg{edgeR}.
The smooth curves for the top row's 3 genes exhibit a generally increasing trend in gene expression over pseudotime, while the curves for the bottom row's 3 genes show a general decreasing trend.
<<Figure10, fig.cap="Scatter plots of expression of top genes along pseudotime. The black dots indicate the observed values, while the red line represents the fitted values calculated along pseudotime.", fig.width = 8.4, fig.height = 5.6, out.width="100%">>=
logCPM.obs <- edgeR::cpm(y, log=TRUE, prior.count=fit$prior.count)
logCPM.fit <- edgeR::cpm(fit, log=TRUE)
topGenes <- c(rownames(tab.up)[1:3], rownames(tab.down)[1:3])
par(mfrow=c(2,3))
for(i in 1:6) {
  Symbol <- topGenes[i]
  logCPM.obs.i <- logCPM.obs[Symbol, ]
  logCPM.fit.i <- logCPM.fit[Symbol, ]
  plot(y$samples$pseudotime, logCPM.obs.i, xlab="pseudotime",
       ylab="log-CPM", main=Symbol, pch=16, frame=FALSE)
  lines(y$samples$pseudotime, logCPM.fit.i, col="red", lwd=2)
}
@

A heatmap is generated to examine the top 20 up and top 20 down genes collectively (Figure 11).
In the heatmap, pseudo-bulk samples are arranged in increasing pseudotime from left to right.
The up genes are on the top half of the heatmap whereas the down genes are on the bottom half.
The heatmap shows a gradual increase in expression levels of the up genes from left to right, while the down genes display the opposite trend.
<<Figure11, fig.cap="Heatmap of top 20 up and top 20 down genes. Rows are genes and columns are pseudo-bulk samples.", fig.width=6, fig.height = 8, out.width="60%">>=
topGenes <- c(rownames(tab.up)[1:20], rownames(tab.down)[1:20])
z <- logCPM.obs[topGenes, ]
z <- t(scale(t(z)))
ComplexHeatmap::Heatmap(z, name = "Z score",
    cluster_rows = FALSE,cluster_columns = FALSE)
@

\section*{Time course functional enrichment analysis}

\subsection*{Gene ontology analysis}

To interpret the results of the time course analysis at the functional level, we perform geneset enrichment analysis.
Gene ontology (GO) is one of the commonly used databases for this purpose.
The GO terms in the GO databases are categorized into three classes: biological process (BP), cellular component (CC) and molecular function (MF). 
In a GO analysis, we are interested in finding GO terms that are over-represented or enriched with significant genes.\newline

GO analysis is usually directional.
For simplicity, we re-perform the QL F-test on the \code{Z1} coefficient to identify genes that exhibit a general linear increase or decrease along pseudotime.
The numbers of genes with a significant increasing or decreasing linear trend are shown below.
<<Test 2nd coefficient>>=
res_2 <- glmQLFTest(fit, coef=2)
summary(decideTests(res_2))
@ 

To perform a GO analysis, we apply the \code{goana} function to the above test results. 
Note that Entrez gene IDs are required for \code{goana}, which has been added to the \code{ENTREZID} column in the gene annotation.
The top enriched GO terms can be viewed using \code{topGO} function.
<<goana>>=
go <- goana(res_2, geneid="ENTREZID", species="Mm")
topGO(go, truncate.term = 30, n=15)
@

It can be seen that most of the top GO terms are down-regulated.
Here, we choose the top 10 down-regulated terms for each GO category and show the results in a barplot (Figure 12).
<<Figure12, fig.cap="Barplot of $-\\log_{10}$ p-values of the top 10 down-regulated GO terms under each GO category.", fig.width=10, fig.height = 7.5, out.width="70%">>=
top_go <- rbind.data.frame(topGO(go, ont =c("BP"), sort="Down",n=10),
                           topGO(go, ont =c("CC"), sort="Down",n=10),
                           topGO(go, ont =c("MF"), sort="Down",n=10))
d <- transform(top_go, P_DE = P.Down, neg_log10_P = -log10(P.Down))
d$Term <- factor(d$Term,levels = d$Term)
ggplot(data = d, aes(x = neg_log10_P, y = Term, fill = Ont) ) +
  geom_bar(stat = "identity", show.legend = TRUE) + 
  labs(x="-log10 (P value)", y="", title = "Down") + 
  facet_grid(Ont~.,scales = "free",space = "free") + 
  my_theme_ggplot + my_theme_facet + 
  scale_fill_manual(values = my_colors_15[-2]) +
  theme(strip.text = ggplot2::element_blank())
@

\subsection*{KEGG pathway analysis}

The Kyoto Encyclopedia of Genes and Genomes (KEGG) is another commonly used database for exploring signaling pathways to understand the molecular mechanism of diseases and biological processes.
A KEGG analysis can be done by using \code{kegga} function. \newline

The top enriched KEGG pathways can be viewed by using \code{topKEGG} function.
<<kegga>>=
kegg <- kegga(res_2, geneid="ENTREZID", species="Mm")
topKEGG(kegg, truncate.path=40, n=15)
@ 

The results show that most of the top enriched KEGG pathways are down-regulated.
Here, we select the top 15 down-regulated KEGG pathways and visualize their significance in a barplot (Figure 13).
<<Figure13, fig.cap="Barplot of $-\\log_{10}$ p-values of the top 15 down-regulated KEGG pathways.", fig.width=8, fig.height = 4.5, out.width="55%">>=
top_path <- topKEGG(kegg,sort="Down",n=15)
data_for_barplot <- transform(top_path, P_DE=P.Down, neg_log10_P=-log10(P.Down))
data_for_barplot$Pathway <- factor(data_for_barplot$Pathway,
                                   levels=data_for_barplot$Pathway)
ggplot(data=data_for_barplot,aes(x=neg_log10_P, y=Pathway) ) +
    geom_bar(stat="identity", show.legend=FALSE, fill=my_colors_15[1]) + 
    labs(x="-log10 (P value)", y="", title="Down" ) + 
    my_theme_ggplot 
@

Among the top down-regulated pathways, the PI3K-Akt signaling pathway is noteworthy as it is typically involved in cell proliferation and plays a crucial role in mammary gland development.\newline 
To assess the overall expression level of the PI3K-Akt signaling pathway across pseudotime, a plot is generated by plotting the average expression level of all the genes in the pathway against pseudotime.
The information of all the genes in the pathway can be obtained by \code{getGeneKEGGLinks} and \code{getKEGGPathwayNames}.
<<keggLinks>>=
kegg_links <- getGeneKEGGLinks("mmu") 
p_names <- getKEGGPathwayNames("mmu")
p1 <- p_names[grep("PI3K", p_names$Description), ] 
p1_GeneIDs <- subset(kegg_links, PathwayID == p1$PathwayID)$GeneID
tab_p1 <- tab[tab$ENTREZID %in% p1_GeneIDs, ]
d <- logCPM.obs[tab_p1$Symbol,]
d <- apply(d, 2, mean)
d <- data.frame(avg_logCPM = d, avg_pseudotime = y$samples$pseudotime)
head(d)
@

The plot below clearly illustrates a significant down-regulation of the PI3K-Akt pathway along pseudotime (Figure 14).
<<Figure14, fig.cap="A smooth curve of PI3K-Akt signaling pathway expression level against pseudotime.", fig.width = 6.5, fig.height = 5, out.width="50%">>=
ggplot(data = d,aes(x = avg_pseudotime, y = avg_logCPM) ) +
    geom_smooth(color=my_colors_15[1],se = FALSE) + 
    labs(x="Pseudotime", y="Average log-CPM", 
         title = "PI3K-Akt signaling pathway" ) + 
    my_theme_ggplot 
@

\section*{Discussion}

In this article, we demonstrated a complete workflow of a pseudo-temporal trajectory analysis of scRNA-seq data.
This workflow takes single-cell count matrices as input and leverages the Seurat pipeline for standard scRNA-seq analysis, including quality control, normalization, and integration.
The \pkg{scDblFinder} package is utilized for doublet prediction. 
Trajectory inference is conducted with \pkg{monocle3}, while the \pkg{edgeR} QL framework with a pseudo-bulking strategy is applied for pseudo-time course analysis.
Alternative methods and packages can be used interchangeably with the ones implemented in this study, as long as they perform equivalent functions.
For instance, the bioconductor workflow may be substituted for the Seurat pipeline in scRNA-seq analysis, whereas the \pkg{slingshot} package may replace \pkg{monocle3} for performing trajectory analysis.\newline

This workflow article utilized 10x scRNA-seq data from five distinct stages of mouse mammary gland development, with a focus on the lineage progression of epithelial cells.
By performing a time course analysis based on pseudotime along the developmental trajectory, we successfully identified genes and pathways that exhibit differential expression patterns over the course of pseudotime.
The results of this extensive analysis not only confirm previous findings in the literature regarding the mouse mammary gland epithelium, but also reveal new insights specific to the early developmental stages of the mammary gland.
The analytical framework presented here can be utilized for any single-cell experiments aimed at studying dynamic changes along a specific path, whether it involves cell differentiation or the development of cell types.


\section*{Packages used}

This workflow depends on various packages from the Bioconductor project version 3.15 and the Comprehensive R Archive Network (CRAN), running on R version 4.2.1 or higher.
The complete list of the packages used for this workflow are shown below:
<<sessionInfo, eval=TRUE>>=
sessionInfo()
@


% save rdata, delete this code chunk after done
<<save rdata, echo=FALSE, eval=eval_save_rdata>>=
save.image(file = "time_course_analysis.rdata")
@


\section*{Data and software availability} % Required

\subsection*{Source data}

The single cell RNA-seq datasets used in this study were obtained from the Gene Expression Omnibus (GEO) with accession numbers of \href{https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE103275}{GSE103275} \cite{pal2017mouse} and \href{https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE164017}{GSE164017} \cite{pal2021mouse}.

\subsection*{Software availability}

All the packages used in this workflow are publicly available from the \href{https://www.bioconductor.org/}{Bioconductor} project (version 3.15) and the Comprehensive R Archive Network (\href{https://cran.r-project.org/}{CRAN}).


\section*{Competing interests}
No competing interests were disclosed.

\section*{Grant information}
This work was supported by the Medical Research Future Fund (MRF1176199 to YC), a University of Melbourne Research Scholarship to JC,
the National Health and Medical Research Council (Fellowship 1154970 to GKS) and the Chan Zuckerberg Initiative (2021-237445 to GKS and YC).

\section*{Acknowledgements}
Not applicable.


{\small\bibliographystyle{unsrtnat}
\bibliography{ref}}
 

% See this guide for more information on BibTeX:
% http://libguides.mit.edu/content.php?pid=55482&sid=406343

% Please note that this template results in a draft pre-submission PDF document.
% Articles will be professionally typeset when accepted for publication.

% We hope you find the F1000Research LaTex template useful, please contact us if you have any feedback.

\end{document}
