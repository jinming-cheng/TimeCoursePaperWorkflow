%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% F1000Research is an Open Research publishing platform for scientists, scholars and clinicians offering rapid publication of articles and other research outputs without editorial bias. All articles benefit from transparent peer review and editorial guidance on making all source data openly available.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This template is for all article types; for information on specific article type requirements please visit https://f1000research.com/for-authors/article-guidelines
%
% For more information on the F1000Research publishing model please see:  https://f1000research.com/about

\documentclass[10pt,a4paper]{article}
\usepackage{f1000_styles}

%% Default: numerical citations
\usepackage[numbers]{natbib}

%% Uncomment this lines for superscript citations instead
%\usepackage[super]{natbib}

%% Uncomment these lines for author-year citations instead
% \usepackage[round]{natbib}
% \let\cite\citep


%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % these code lines are added by authors
%                           %

\usepackage{orcidlink}      %%%    added by Jinming   %%%

\newcommand{\code}[1]{{\small\texttt{#1}}}
\newcommand{\pkg}[1]{\textit{#1}}
% \newcommand{\Biocpkg}[1]{\textit{#1}}
% \newcommand{\Rclass}[1]{{\small\texttt{#1}}}

\newcommand{\gene}[1]{\textit{#1}}

% % Allowing the large floats to have some text in those pages.
% \renewcommand{\topfraction}{0.8}
% \renewcommand{\floatpagefraction}{0.75}

%                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\pagestyle{fancy}

\title{Unraveling the timeline of gene expression: A pseudotemporal trajectory analysis of single-cell RNA sequencing data}
\author[1,2]{Jinming Cheng \orcidlink{0000-0003-3806-4694} } 
\author[1,3,*]{Gordon K. Smyth \orcidlink{0000-0001-9221-2892} }
\author[1,2,4,*]{Yunshun Chen \orcidlink{0000-0003-4911-5653} }

\affil[*]{ Correspondence: smyth@wehi.edu.au, yuchen@wehi.edu.au }
\affil[1]{ Bioinformatics Division, The Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia } 
\affil[2]{ Department of Medical Biology, The University of Melbourne, Parkville, VIC 3010, Australia }
\affil[3]{ School of Mathematics and Statistics, The University of Melbourne, Parkville, VIC 3010, Australia } 
\affil[4]{ ACRF Cancer Biology and Stem Cells Division, The Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia }


\maketitle
\thispagestyle{fancy}

<<style, include=FALSE>>=
knitr::opts_chunk$set(error=FALSE,
                      eval=TRUE, # use FALSE for test
                      prompt=TRUE, 
                      message=FALSE,
                      warning=FALSE,
                      comment=NA)

knitr::opts_chunk$set(fig.width=7, fig.height=7, out.width="100%", fig.align="center", fig.path="Figures/") 
knitr::opts_chunk$set(dpi=300, dev="png", 
                      #dev.args=list(pointsize=15), 
                      cache=FALSE, cache.lazy=FALSE)
options(width=83,digits=3)

options(kableExtra.latex.load_packages = FALSE)

options(timeout=300) # to slove "Timeout of 60 seconds was reached" in download.file 

# replace 'xcolor' with 'color' in the tex file
knitr::knit_hooks$set(document = function(x) {sub('\\usepackage[]{xcolor}', '\\usepackage{color}', x, fixed = TRUE)})
@


<<chunkEval, include=FALSE>>=
eval_download = TRUE
eval_single_sample_Seurat = TRUE
eval_1st_integration = TRUE
eval_prepare_pseudobulk = TRUE
eval_cds = TRUE
eval_save_rdata = TRUE
@


<<load packages, include=FALSE, eval = !eval_1st_integration, purl=FALSE>>=
library(edgeR) 
library(ggplot2)
library(Seurat)
library(monocle3)
@

~\\
\begin{abstract}
\textbf{Background:} Single-cell RNA sequencing (scRNA-seq) technologies have rapidly developed in recent years. The droplet-based single-cell platforms enable the profiling of gene expression in tens of thousands of cells per sample. The goal of a typical scRNA-seq analysis is to identify different cell subpopulations and their respective marker genes. Additionally, trajectory analysis can be used to infer the developmental or differentiation trajectories of cells.\\
\textbf{Methods:} This article demonstrates a comprehensive workflow for performing trajectory inference and time course analysis on a multi-sample single-cell RNA-seq experiment of the mouse mammary gland. The workflow uses open-source R software packages and covers all steps of the analysis pipeline, including quality control, doublet prediction, normalization, integration, dimension reduction, cell clustering, trajectory inference, and pseudo-bulk time course analysis. Sample integration and cell clustering follows the Seurat pipeline while the trajectory inference is conducted using the monocle3 package. The pseudo-bulk time course analysis uses the quasi-likelihood framework of edgeR.\\
\textbf{Results:} Cells are ordered and positioned along a pseudotime trajectory that represented a biological process of cell differentiation and development. The study successfully identified genes that were significantly associated with pseudotime in the mouse mammary gland.\\
\textbf{Conclusions:} The demonstrated workflow provides a valuable resource for researchers conducting scRNA-seq analysis using open-source software packages. The study successfully demonstrated the usefulness of trajectory analysis for understanding the developmental or differentiation trajectories of cells. This analysis can be applied to various biological processes such as cell development or disease progression, and can help identify potential biomarkers or therapeutic targets.
\end{abstract}


\section*{\color{f1ROrange}Keywords}

Single-cell RNA-seq, mammary gland, trajectory analysis, time course analysis, pseudo-bulk, differential expression analysis

\clearpage
\pagestyle{fancy}

\section*{Introduction}

Single-cell RNA sequencing (scRNA-seq) has emerged as a popular technique for transcriptomic profiling of samples at the single-cell level. With droplet-based methods, thousands of cells can be sequenced in parallel using next-generation sequencing platforms \cite{macosko2015DropSeq,klein2015inDrop}.
One of the most widely used droplet-based scRNA-seq technologies is the 10x Genomics Chromium which enables profiling transcriptomes of tens of thousands of cells per sample \cite{zheng2017nc10X}.
A common goal of a scRNA-seq analysis is to investigate cell types and states in heterogeneous tissues. To achieve this, various pipelines have been developed, such as \pkg{Seurat} \cite{hao2021SeuratV4}, the Bioconductor’s OSCA pipeline \cite{amezquita2020orchestrating}, and \pkg{scanpy} \cite{wolf2018scanpy}.
A typical scRNA-seq data analysis pipeline involves quality control, normalization, dimension reduction, cell clustering, and differential expression analysis. \newline

With the advent of single-cell multiplexing technologies, the per sample cost of scRNA-seq experiments has significantly decreased. 
This makes it feasible and mroe affordable to conduct single-cell RNA-seq profiling across a variety of biological samples within a given experimental study.
In a multiple sample single-cell experiment, an integration method is required to investigate all cells across all samples simultaneously. This ensures that sample and batch effects are appropriately considered in visualizing and clustering cells. Popular integration methods include the Seurat’s anchor-based integration method \cite{hao2021SeuratV4}, Harmony \cite{korsunsky2019fast}, and the MNN \cite{haghverdi2018batch}.\newline

After integration and cell clustering, differential expression analysis is often performed to identify marker genes for each cell cluster. 
Various methods have been developed at the single-cell level for finding marker genes \cite{risso2018zinbwave,lun2016scran}.
Recently, the pseudo-bulk method has become increasingly popular due to its superior computational efficiency and its ability to consider biological variation between replicate samples \cite{crowell2020muscat}. 
Under this approach, pseudo-bulk expression profiles are formed by aggregating read counts for all cells within the same group (e.g., cluster, cell type) and from the same sample.
\newline

Trajectory inference is another popular downstream analysis that aims to study cell differentiation or cell type development. 
Popular software tools to perform trajectory analysis include \pkg{monocle3} \cite{cao2019monocle3} and \pkg{slingshot} \cite{street2018slingshot}.
These methods learn trajectories based on the change of gene expression and order cells along a trajectory to obtain pseudotime \cite{trapnell2014monocle, saelens2019comparison}.
This allows for pseudotime-based time course analysis in single-cell experiments, which is extremely useful for investigating specific biological questions of interest.\newline

Here we present a new single-cell workflow that integrates trajectory analysis and pseudo-bulking to execute a single-cell pseudo time course analysis. The inputs for this workflow are single-cell count matrices, such as those generated by 10x Genomic’s \pkg{cellranger}.
The methods involved open source packages in R. 
The single-cell QC, clustering and integration analyses are performed in \pkg{Seurat}, whereas the trajectory analysis is conducted using \pkg{monocle3}.
Once the pseudo-bulk samples are created and assigned pseudotime, a time course analysis is conducted in \pkg{edgeR} \cite{mccarthy2012edgeR}.
The analysis pipeline presented in this article can be used for examining dynamic cellular changes along a specific trajectory in any single-cell RNA-seq experiment with replicate samples.
\newline 


\section*{Description of the biological experiment}

The scRNA-seq data used to demonstrate this workflow consists of five mouse mammary epithelium samples at five different stages: embryonic, early postnatal, pre-puberty, puberty and adult. The puberty sample is from the study in Pal et al. 2017 \cite{pal2017mouse}, whereas the other samples are from Pal et al. 2021 \cite{pal2021mouse}.
These studies examined the stage-specific single-cell profiles in order to gain insight into the early developmental stages of mammary gland epithelial lineage.
The \pkg{cellranger} count matrix outputs of these five samples are available on the GEO repository as series \href{https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE103275}{GSE103275} and \href{https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE164017}{GSE164017}.


\section*{Package installation}

Bioconductor packages used for this workflow can be installed as follows.
<<BioPackages, eval=FALSE>>=
install.packages("BiocManager")
BiocManager::install("edgeR")
BiocManager::install("org.Mm.eg.db")
BiocManager::install("GO.db")
BiocManager::install("scDblFinder")
BiocManager::install("ComplexHeatmap")
@

CRAN packages used for this workflow can be installed as follows.
<<CranPackages, eval=FALSE>>=
install.packages("Seurat")
install.packages("R.utils")
install.packages("remotes")
@

GitHub packages used for this workflow can be installed as follows.
<<GitPackages, eval=FALSE>>=
remotes::install_github("satijalab/seurat-wrappers")
remotes::install_github("cole-trapnell-lab/monocle3")
@


\section*{Data preparation}

\subsection*{Downloading the data}

The \pkg{cellranger} output of each sample consists of three key files: a count matrix in \code{mtx.gz} format, barcode information in \code{tsv.gz} format and feature (or gene) information in \code{tsv.gz} format.
The outputs of the mouse mammary epithelium at embryonic stage (E18.5), post-natal 5 days (P5), 2.5 weeks (Pre-puberty), and 10 weeks (Adult) can be downloaded from \href{https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE164017}{GSE164017} \cite{pal2021mouse}, whereas the output of mouse mammary epithelium at 5 weeks (Puberty) can be downloaded from \href{https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE103275}{GSE103275} \cite{pal2017mouse}. \newline

We first create a \code{data} directory to store all the data files.
<<data dir>>=
data_dir <- "data"
if(!dir.exists(data_dir)){dir.create(data_dir, recursive=TRUE)}
@

<<rds file dir,include=FALSE,purl=FALSE>>=
rds_res_dir <- "results/rds_files"
if(!dir.exists(rds_res_dir)){dir.create(rds_res_dir, recursive=TRUE)}
@

We then download the barcode and count matrix files of the five samples.
<<barcode and matrix files, include=FALSE, purl=FALSE>>=
accessions <-c("GSM4994960","GSM4994962","GSM4994963","GSM2759554","GSM4994967")
stages <- c("E18-ME", "Pre-D5-BL6", "Pre-BL6", "5wk-1", "Adult-BL6")
file_suffixes <- c("barcodes.tsv.gz", "matrix.mtx.gz")
@

<<barcode and matrix files pal2021and2017, eval = eval_download>>=
accessions <-c("GSM4994960","GSM4994962","GSM4994963","GSM2759554","GSM4994967")
stages <- c("E18-ME", "Pre-D5-BL6", "Pre-BL6", "5wk-1", "Adult-BL6")
file_suffixes <- c("barcodes.tsv.gz", "matrix.mtx.gz")
for ( i in 1:length(accessions) ) {
  for (file_suffix in file_suffixes) {
    filename <- paste0(accessions[i],"_",stages[i],"-",file_suffix)
    url <- paste0("http://www.ncbi.nlm.nih.gov/geo/download/?acc=",
                  accessions[i],"&","format=file&","file=",filename)
    download.file(url=url,destfile=paste0(data_dir,"/",filename))
  }
}
@

Since the five samples in this workflow are from two separate studies and were processed using different cellranger references but built from the same mouse genome (mm10), the feature information is slightly different between the two runs.
In general, the same cellranger reference build is preferred for the sake of consistency, although the effect on the downstream analysis is negligible.
Here, we download the feature information of both runs. The \code{GSM2759554\_5wk-1-genes.tsv.gz} file contains the feature information for the \code{5wk-1} sample, whereas \code{GSE164017\_features.tsv.gz} contains the feature information for the other four samples.
<<featureFiles,  include=FALSE, purl=FALSE>>=
GSE <- c("GSE164017", "GSM2759554")
feature_filenames <- c("GSE164017_features.tsv.gz",
                       "GSM2759554_5wk-1-genes.tsv.gz")
@

<<feature file pal2021and2017, eval = eval_download>>=
GSE <- c("GSE164017", "GSM2759554")
feature_filenames <- c("GSE164017_features.tsv.gz",
                       "GSM2759554_5wk-1-genes.tsv.gz")
for (i in 1:length(GSE) ) {
  url <- paste0("http://www.ncbi.nlm.nih.gov/geo/download/?acc=",
                GSE[i],"&","format=file&","file=",feature_filenames[i])
  download.file(url=url,destfile=paste0(data_dir,"/",feature_filenames[i]))
}
@

A target information file is created to store all the sample and file information.
<<targets>>=
samples <- c("E18.5-epi", "P5", "Pre-puberty", "Puberty", "Adult")
targets <- data.frame(
    samples=samples,
    stages=stages, 
    accessions=accessions,
    matrix.file = paste0("data/",accessions[1:5],"_",stages[1:5],"-","matrix.mtx.gz"), 
    barcode.file = paste0("data/",accessions[1:5],"_",stages[1:5],"-","barcodes.tsv.gz"), 
    feature.file = paste0("data/",feature_filenames[c(1,1,1,2,1)]))
targets
@

\subsection*{Reading in the data}

The downloaded \pkg{cellranger} outputs of all the samples can be read in one-by-one using the \code{read10X} function in the \pkg{edgeR} package.
First, a \code{DGElist} object is created for each sample, which is then consolidated into a single \code{DGElist} object by merging them altogether.
<<read and merge data>>=
library(edgeR)
dge_all <- list()
for ( i in 1:5 ) {
  y <- read10X(mtx = targets$matrix.file[i], 
      barcodes = targets$barcode.file[i], genes = targets$feature.file[i])
  y$samples$group <- targets$samples[i]
  colnames(y) <- paste0(targets$accessions[i],"-",y$samples$Barcode)
  y$genes$Ensembl_geneid <- rownames(y)
  y$genes <- y$genes[,c("Ensembl_geneid","Symbol")]
  y <- y[!duplicated(y$genes$Symbol),]
  rownames(y) <- y$genes$Symbol
  dge_all[[i]] <- y
}
rm(y)
common.genes <- Reduce(intersect, lapply(dge_all, rownames))
for(i in 1:5) dge_all[[i]] <- dge_all[[i]][common.genes, ]
dge_merged <- do.call("cbind", dge_all)
@

The levels of \code{group} in the sample information data frame are reordered and renamed from the early embryonic stage to the late adult stage.
<<relevel groups>>=
dge_merged$samples$group <- factor(dge_merged$samples$group, levels=samples)
@

The number of genes, the total number of cells, and the number of cells in each sample are shown below.
<<dim of merged data>>=
dim(dge_merged)
table(dge_merged$samples$group)
@


\section*{Single-cell RNA-seq analysis}

\subsection*{Quality control}

Quality control (QC) is essential for single-cell RNA-seq data analysis. Common choices of QC metrics include number of expressed genes or features, total number of reads, and proportion of reads mapped to mitochondrial genes in each cell. The number of expressed genes and mitochondria read percentage in each cell can be calculated as follows.
<<quality control>>=
dge_merged$samples$num_exp_gene <- colSums(dge_merged$counts>0)
mito_genes <- rownames(dge_merged)[grep("^mt-",rownames(dge_merged))]
dge_merged$samples$mito_percentage <- 
  colSums(dge_merged$counts[mito_genes,])/
  colSums(dge_merged$counts)*100
@

These QC metrics can be visualized in the following scatter plots (Figure 1).
<<set theme and colors for ggplot2>>=
library(ggplot2)
my_theme_ggplot <- theme_classic() + 
  theme(axis.text=element_text(size=12),
        axis.title=element_text(size=15,face="bold"),
        plot.title=element_text(size=15,face="bold",hjust=0.5),
        plot.margin=margin(0.5, 0.5, 0.5, 0.5, "cm"))
my_theme_facet <- 
  theme(strip.background=element_rect(colour="white",fill="white"),
        strip.text=element_text(size=15, face="bold",color="black")) 
my_colors_15 <- c("cornflowerblue", "darkorchid1", "firebrick1", "gold",
                  "greenyellow", "mediumspringgreen", "mediumturquoise",
                  "orange1", "pink", "deeppink3", "violet", "magenta",
                  "goldenrod4", "cyan", "gray90")
@

<< Figure1, fig.cap="Scatter plots of quality control metrics across all the samples. Each dot represents a cell. The plots on the left show number of reads vs number of genes detected, whereas those on the right show number of reads vs mitochondria read percentage.",fig.height = 2*5*0.8,fig.width=4*2*0.8,out.width="70%">>=
p1 <- ggplot(data = dge_merged$samples,
             aes(x=num_exp_gene, y=lib.size, color = group ) ) + 
      geom_point(size=0.5, show.legend=FALSE) + 
      facet_wrap(group~., ncol=1) + 
      scale_color_manual(values=my_colors_15 ) + 
      labs(x="Number of genes", y="Number of reads") +
      my_theme_ggplot + my_theme_facet
p2 <- ggplot(data = dge_merged$samples,
             aes(x = mito_percentage, y=lib.size, color = group ) ) + 
      geom_point(size = 0.5, show.legend = FALSE) + 
      facet_wrap(group~., ncol=1) + 
      scale_color_manual(values=my_colors_15) + 
      labs(x="Mito-percentage", y="Number of reads") +
      my_theme_ggplot + my_theme_facet
patchwork::wrap_plots(p1, p2, ncol=2)
@


Cells with a very low number of genes (<500) are considered of low quality and hence are removed from the analysis.
Cells with high mitochondria read percentage (>10\%) are also removed as high expression level of mitochondrial genes indicate damaged or dead cells.
In general, these QC thresholds are dependent on the study data and hence should be considered carefully.
For example, quiescent cells may normally have low RNA expression levels, and metabolically active cells may have a high mitochondrial content.\newline

Cells expressing a large number of genes are also removed as they are likely to be doublets.
Even though a separate doublet detection analysis is performed later on, we notice from our own practise that the combination of both doublet detection and the removal of cells with large counts works the best.
Different thresholds are selected for different samples based on the distribution of the number of genes expressed. 
Here, we choose 5000, 6000, 6000, 3000, 4000 for E18.5-epi, P5, pre-puberty, puberty and adult samples, respectively.\newline

In this workflow, most of the single-cell analysis is conducted using the \pkg{Seurat} package.
We begin by reading in the scRNA-seq data from the five samples together with an initial QC process.
Specifically, we filter out genes expressed in fewer than 3 cells and cells expressing fewer than 200 genes for each sample.
Then the abovementioned QC thresholds are applied in order to further remove cells of low quality in each sample.
The data after QC are stored as a list of five Seurat objects.\newline

<<cell filtering, results='hide',eval=eval_single_sample_Seurat>>=
library(Seurat)
n_genes_max <- c(5000, 6000, 6000, 3000, 4000)
data_seurat <- list()
for (i in 1:5) {
  sel <- dge_merged$samples$group == samples[i]
  y <- dge_merged[, sel]
  data_seurat[[i]] <- CreateSeuratObject( counts=y$counts,
      meta.data=y$samples, min.cells=3, min.features=200,
      project=samples[i] )
  data_seurat[[i]] <- subset( data_seurat[[i]],
      subset = (nFeature_RNA > 500) & (nFeature_RNA < n_genes_max[i]) &
                 (mito_percentage < 10) )
}
names(data_seurat) <- samples
@

\subsection*{Standard Seurat analysis of individual sample}

A standard Seurat analysis is performed for each individual sample.
This would provide us some general information on how each individual sample looks like and what cell types present within them.
More details on how to perform a scRNA-seq analysis can be found in Seurat online vignettes.\newline

For each individual sample analysis, the default log normalization method in \code{NormalizeData} is applied to each sample. The top 2000 highly variable genes (HVGs) are identified by \code{FindVariableFeatures}. The normalized data of the 2000 HVGs are scaled by \code{ScaleData} to have a mean of 0 and a variance of 1. The principal component analysis (PCA) dimension reduction is performed on the HVGs by \code{RunPCA}. Uniform manifold approximation and projection (UMAP) dimension reduction is performed on the first 30 principal components (PCs) by \code{RunUMAP}. Here we use the first 30 PCs to be consistent with the analysis in Pal et al. 2021 \cite{pal2021mouse}. Based on the Seurat vignette and our own practise, the number of PCs chosen would not change the results dramatically if it is large enough (> 10). Cell clustering is performed individually for each sample by \code{FindNeighbors} and \code{FindClusters}, which by default uses the Louvain algorithm. Cell clustering resolution is carefully chosen for each sample so that distinct cell types are grouped into separate clusters. For this dataset, the cell clustering resolution is set at 0.1, 0.1, 0.2, 0.2 and 0.2 for E18.5-epi, P5, pre-puberty, puberty and adult, respectively.

<<analysis of each sample, results='hide', eval=eval_single_sample_Seurat>>=
data_seurat <- lapply(data_seurat, NormalizeData)
data_seurat <- lapply(data_seurat, FindVariableFeatures, nfeatures=2000)
data_seurat <- lapply(data_seurat, ScaleData)
data_seurat <- lapply(data_seurat, RunPCA, verbose = FALSE)
data_seurat <- lapply(data_seurat, RunUMAP, reduction = "pca", dims = 1:30)
data_seurat <- lapply(data_seurat, FindNeighbors, reduction="pca", dims=1:30)
resolutions <- c(0.1, 0.1, 0.2, 0.2, 0.2)
for(i in 1:5)
    data_seurat[[i]] <- FindClusters(data_seurat[[i]], 
        resolution=resolutions[i], verbose=FALSE)
@

\subsection*{Removing potential doublets and non-epithelial cells}

Although high-throughput droplet-based single-cell technologies can accurately capture individual cells, there are instances where a single droplet may contain two or more cells, which are known as doublets or multiplets.
Here we use the \pkg{scDblFinder} package \cite{germain2021doublet} to further remove potential doublets.
To do that, each Seurat object in the list is first converted into a \code{SingleCellExperiment} object using the \code{as.SingleCellExperiment} function in \pkg{Seurat}.
Then the \code{scDblFinder} function in the \pkg{scDblFinder} package is called to predict potential doublets on each \code{SingleCellExperiment} object.
The \code{scDblFinder} output for each sample is stored in the corresponding Seurat object.

<<doublet detection, results='hide',eval=eval_single_sample_Seurat>>=
library(scDblFinder)
for (i in 1:5) {
  sce <- as.SingleCellExperiment(DietSeurat(data_seurat[[i]], 
      graphs=c("pca","umap")) )
  set.seed(42)
  sce <- scDblFinder(sce)
  data_seurat[[i]]$db_score <- sce$scDblFinder.score
  data_seurat[[i]]$db_type <- factor( sce$scDblFinder.class, 
      levels=c("singlet", "doublet") )
}
@

<<save rds single sample analysis, include=FALSE, eval=eval_single_sample_Seurat, purl=FALSE>>=
filename_rds = paste0(rds_res_dir,"/","data_seurat",".rds")
saveRDS(data_seurat, file = filename_rds)
@

<<read rds single sample analysis, include=FALSE, eval=!eval_single_sample_Seurat, purl=FALSE>>=
filename_rds = paste0(rds_res_dir,"/","data_seurat",".rds")
data_seurat = readRDS(filename_rds)
@

The main object of this single-cell experiment is to examine the early developmental stages of the mouse epithelial mammary gland.
Hence, for the rest of the analysis we will mainly focus on the epithelial cell population which is typically marked by the \gene{Epcam} gene.
The cell clustering, the expression level of \gene{Epcam} and doublet prediction results of each sample are shown below (Figure 2).
<< Figure2, fig.cap="UMAP visualization of each individual sample. The UMAP plots, in sequence from the top row to the bottom row, correspond to E18.5-epi, P5, Pre-puberty, Puberty, and Adult, respectively. In each row, cells are coloured by cluster on the left, by Epcam expression level in the middle, and by doublet prediction on the right.", fig.height = 16, fig.width=12, out.width="85%">>=
p1 <- lapply(data_seurat,function(x){DimPlot(x, pt.size=0.1, cols=my_colors_15) + 
                ggtitle(x$group[1]) + theme(plot.title=element_text(hjust=0.5))})
p2 <- lapply(data_seurat, FeaturePlot, feature="Epcam", pt.size=0.1)
p3 <- lapply(data_seurat, DimPlot, group.by="db_type", pt.size=0.1, 
             cols=c("gray90", "firebrick1"))
patchwork::wrap_plots(c(p1,p2,p3), nrow=5, byrow=FALSE)
@

By examining the expression level of the \gene{Epcam} gene, together with some other known marker genes of basal, LP and ML, we select the following clusters in each sample as the epithelial cell population.
<<epi clusters>>=
epi_clusters <- list(
  "E18.5-epi" = 0,
  "P5" = c(1,3),
  "Pre-puberty" = c(0:2, 5),
  "Puberty" = 0:6,
  "Adult" = 0:3
)
@

Cells that are non-epithelial and those identified as potential doublets by \pkg{scDblFinder} are excluded from the subsequent analysis. 
The cellular barcodes of the remaining epithelial cells from each sample are stored in the list object called \code{epi\_cells}.
The respective number of epithelial cells that are retained for each sample is shown below.
<<epi cell filtering>>=
epi_cells <- list()
for (i in samples) {
  epi_cells[[i]] <- rownames(
    subset(data_seurat[[i]]@meta.data,
      (db_type == "singlet") & (seurat_clusters %in% epi_clusters[[i]])))
}
do.call(c, lapply(epi_cells, length))
@


\section*{Data integration}

\subsection*{Integrating epithelial cells of five samples}

Since we have five individual scRNA-seq samples, conducting an integration analysis is necessary to explore all cells across these samples simultaneously.
In this workflow, we use the default anchor-based integration method of the \pkg{Seurat} package.
Depending on the single-cell analysis workflow, users are free to use other integration methods they may prefer (e.g., Harmony and MNN).\newline

A Seurat object is first created from the merged \code{DGEList} object of epithelial cells using \code{CreateSeuratObject} function without filtering any cells (\code{min.features} is set to 0).
Lowly expressed genes are removed as they are not of any biological interest here.
Here we keep genes expressed in at least 3 cells in each sample (\code{min.cells} is set to 3) although different thresholds can be adopted in general depending on the data.
<<merge epi cells>>=
epi_cells <- do.call(c, epi_cells)
dge_merged_epi <- dge_merged[, epi_cells]
seurat_merged <- CreateSeuratObject(counts = dge_merged_epi$counts,
                      meta.data = dge_merged_epi$samples,
                      min.cells = 3, min.features = 0, project = "mammary_epi")
@

Then the Seurat object is split into a list of five Seurat objects, where each object corresponds to one of the five samples.
For each sample, the log normalization method is applied to normalize the raw count by \code{NormalizeData}, and highly variable genes are identified by \code{FindVariableFeatures}.
<<split seurat epi>>=
seurat_epi <- SplitObject(seurat_merged, split.by = "group")
seurat_epi <- lapply(seurat_epi, NormalizeData)
seurat_epi <- lapply(seurat_epi, FindVariableFeatures, nfeatures = 2000)
@

The feature genes used for integration are chosen by \code{SelectIntegrationFeatures}, and these genes are used to identify anchors for integration by \code{FindIntegrationAnchors}.
The integration process is performed by \code{IntegrateData} based on the identified anchors.
Please note that the integration step is computationally intensive and might take a substantial amount of time to complete (20$-$40 minutes depending on the computational resource).
<<Seurat integration, results='hide', eval=eval_1st_integration>>=
anchor_features <- SelectIntegrationFeatures(seurat_epi,
                      nfeatures = 2000, verbose = FALSE)
anchors <- FindIntegrationAnchors(seurat_epi, verbose = FALSE,
                      anchor.features = anchor_features)
seurat_int <- IntegrateData(anchors, verbose = FALSE)
@

The integrated data are then scaled to have a mean of 0 and a variance of 1 by \code{ScaleData}. 
PCA is performed on the scaled data using \code{RunPCA}, followed by UMAP using \code{RunUMAP}.
Same as before, we use 30 PCs for the sake of consistency and the results would not change dramatically provided a good amount of PCs (>10) are used.
Cell clusters of the integrated data are identified by using \code{FindNeighbors} and \code{FindClusters}.
We choose 0.2 as the cell clustering resolution after experimenting with different resolution parameters.
This is because under this resolution the three major epithelial subpopulations, two intermediate cell clusters, and a small group of stroma cells can be clearly separated in distinct cell clusters.
<<Seurat integration 2, results='hide', eval=eval_1st_integration>>=
DefaultAssay(seurat_int) <- "integrated"
seurat_int <- ScaleData(seurat_int, verbose = FALSE)
seurat_int <- RunPCA(seurat_int, npcs = 30, verbose = FALSE)
seurat_int <- RunUMAP(seurat_int, reduction = "pca",
                  dims = 1:30, verbose = FALSE)
seurat_int <- FindNeighbors(seurat_int, dims = 1:30, verbose = FALSE)
seurat_int <- FindClusters(seurat_int, resolution = 0.2, verbose = FALSE)
@

<<save rds 1st integration, include=FALSE, eval=eval_1st_integration, purl=FALSE>>=
filename_rds = paste0(rds_res_dir,"/","seurat_int",".rds")
saveRDS(seurat_int, file = filename_rds)
@

<<read rds 1st integration, include=FALSE, eval=!eval_1st_integration, purl=FALSE>>=
filename_rds = paste0(rds_res_dir,"/","seurat_int",".rds")
seurat_int = readRDS(filename_rds)
@

UMAP plots are generated to visualize the integration and cell clustering results (Figure 3).
The UMAP plot indicates the presence of three major cell clusters (cluster 0, 1, and 2), which are bridged by intermediate clusters located in between them.
Cells at the later stages largely dominate the three major cell clusters, while cells at the earlier stages are predominantly present in the intermediate clusters in the middle.
<<Figure3, fig.cap="UMAP visualization of the integrated data. Cells are coloured by cluster on the left and by original sample on the right.", fig.height = 5, fig.width=12, out.width="100%">>=
seurat_int$group <- factor(seurat_int$group, levels = samples)
p1 <- DimPlot(seurat_int, pt.size = 0.1, cols = my_colors_15)
p2 <- DimPlot(seurat_int, pt.size = 0.1, group.by = "group", 
          shuffle = TRUE, cols = my_colors_15) + labs(title="")
p1 | p2
@

\subsection*{Cell type identification}

The mammary gland epithelium consists of three major cell types: basal myoepithelial cells, luminal progenitor (LP) cells and mature luminal (ML) cells.
These three major epithelial cell populations have been well studied in the literature.
By examining the classic marker genes of the three cell types, we are able to identify basal, LP and ML cell populations in the integrated data (Figure 4). 
Here we use \gene{Krt14} and \gene{Acta2} for basal, \gene{Csn3} and \gene{Elf5} for LP, and \gene{Prlr} and \gene{Areg} for ML.
We also examine the expression level of \gene{Hmgb2} and \gene{Mki67} as they are typical markers for cycling cells and the expression level of \gene{Igfbp7} and \gene{Fabp4} as they are marker genes for stromal cells.
<<Figure4,  fig.cap="Feature plots of the integrated data. Genes from the top row to the bottom rows are the markers of basal, LP, ML, cycling, and stromal cells, respectively.", fig.width=4*2, fig.height = 3*5, out.width="60%">>=
markers <- c("Krt14", "Acta2", "Csn3","Elf5", "Prlr","Areg", 
             "Hmgb2", "Mki67", "Igfbp7","Fabp4")
DefaultAssay(seurat_int) <- "RNA"
FeaturePlot(seurat_int, order = TRUE, pt.size = 0.1, features = markers, ncol = 2)
@

Based on the feature plots, cluster 1, cluster 2 and cluster 0 represent the basal, LP and ML cell populations, respectively. Cluster 4 mainly consists of cycling cells, whereas cluster 3 seems to be a luminal intermediate cell cluster expressing both LP and ML markers. Cluster 5 consists of a few non-epithelial (stromal) cells that have not been filtered out previously.\newline

The number of cells in each cluster for each sample is shown below.
<<table cell number>>=
tab_number <- table(seurat_int$group, seurat_int$seurat_clusters)
tab_number
@

The proportion of cells in each cluster is calculated for each sample to compare the variation in cell composition across different stages.
<<table cell proportion>>=
tab_ratio <- round(100*tab_number/rowSums(tab_number), 2)
tab_ratio <- as.data.frame.matrix(tab_ratio)
tab_ratio
@

The bar plot (Figure 5) shows the proportion of different cell types in samples at different developmental stages. 
Specifically, the proportion of basal cells (purple) demonstrates an ascending trend from E18.5 to pre-puberty stage, after which it declines towards adult stage.
The LP cell proportion (red) rises from E18.5 to puberty stage, followed by a slight dip at adult stage.
Although the proportion of ML cells (blue) is higher at P5 than pre-puberty stage, it shows an overall increasing trend.
Cycling cells (green) constitute the highest proportion at E18.5 stage, but decrease to a smaller proportion at pre-puberty stage, with a slight increase at puberty stage, and subsequently, they reduce to a negligible proportion at adult stage.
The augmented cycling cell proportion at puberty stage aligns with the ductal morphogenesis characteristics of the mammary gland.
The luminal intermediate cell proportion (yellow) displays a decreasing trend from E18.5 stage to adult stage.

<<Figure5, fig.cap="Bar plot of cell proportion of each cluster in each sample.",fig.width = 6, fig.height = 4, out.width="55%">>=
par(mar=c(5, 7, 1, 7), xpd=TRUE)
barplot(t(tab_ratio), col=my_colors_15, xlab="Cell proportion (%)", 
    horiz = TRUE, las=1)
legend("right", inset = c(-0.3,0), legend = 0:5, pch = 15, 
    col=my_colors_15, title="Cluster")
@


\section*{Trajectory analysis with monocle3}

\subsection*{Constructing trajectories and pseudotime}

Many biological processes manifest as a dynamic sequence of alterations in the cellular state, which can be estimated through a "trajectory" analysis.
Such analysis is instrumental in detecting the shifts between different cell identities and modeling gene expression dynamics.
By treating single-cell data as a snapshot of an uninterrupted process, the analysis establishes the sequence of cellular states that forms the process trajectory.
The arrangement of cells along these trajectories can be interpreted as pseudotime.\newline

Here, we use the \pkg{monocle3} package to infer the development trajectory in the mouse mammary gland epithelial cell population.
The Seurat object of the integrated data is first converted into a \code{cell\_data\_set} object to be used in \pkg{monocle3}.
<<prepare cds object, eval=eval_cds>>=
library(monocle3)
cds_obj <- SeuratWrappers::as.cell_data_set(seurat_int)
@

\pkg{monocle3} re-clusters cells to assign them to specific clusters and partitions, which are subsequently leveraged to construct trajectories.
If multiple partitions are used, each partition will represent a distinct trajectory.
The calculation of pseudotime, which indicates the distance between a cell and the starting cell in a trajectory, is conducted during the trajectory learning process.
These are done using the \code{cluster\_cells} and \code{learn\_graph} functions. 
To obtain a single trajectory and avoid a loop structure, both \code{use\_partition} and \code{close\_loop} are turned off in \code{learn\_graph}.

<<cluster cell and learn graph, eval=eval_cds>>=
set.seed(42)
cds_obj <- cluster_cells(cds_obj)
cds_obj <- learn_graph(cds_obj, use_partition=FALSE, close_loop=FALSE)
@

<<save rds cds object, eval=eval_cds, include=FALSE, purl=FALSE>>=
filename_rds = paste0(rds_res_dir,"/", "cds_obj_final",".rds")
saveRDS(cds_obj, file = filename_rds)
@

<<read rds cds object, eval=!eval_cds, include=FALSE, purl=FALSE>>=
filename_rds = paste0(rds_res_dir,"/", "cds_obj_final",".rds")
cds_obj = readRDS(filename_rds)
@

\subsection*{Visualizing trajectories and pseudotime}

The \code{plot\_cells} function of \pkg{monocle3} is used to generate a trajectory plot that superimposes the trajectory information onto the UMAP representation of the integrated data.
By adjusting the \code{label\_principal\_points} parameter, the names of roots, leaves, and branch points can be displayed.
Cells in the trajectory UMAP plot (Figure 6) are coloured by cell cluster identified in the previous Seurat integration analysis.

<<Figure6, fig.cap="UMAP visualization of trajectory inferred by monocle3. Cells are coloured by cluster.", fig.width=5*1.2, fig.height = 4*1.2, out.width="55%">>=
p1 <- plot_cells(cds_obj, color_cells_by="seurat_clusters",
                 group_label_size=4, graph_label_size=3,
                 label_cell_groups=FALSE, label_principal_points=TRUE,
                 label_groups_by_cluster=FALSE) + 
      scale_color_manual(values = my_colors_15)
p1 
@


Along the \pkg{monocle3} trajectory analysis, several nodes are identified and marked with black circular dots on the resulting plot, representing principal nodes along the trajectories.
To establish the order of cells and calculate their corresponding pseudotime, it is necessary to select a starting node among the identified principal nodes.
For this analysis, node \code{"Y\_65"} in the basal population (cluster 1) was selected as the starting node, as mammary stem cells are known to be enriched in the basal population and give rise to LP and ML cells in the epithelial lineage \cite{shackleton2006stemcell}.
It should be noted that node numbers may vary depending on the version of monocle3 used.

<<orderCells>>=
cds_obj <- order_cells(cds_obj, root_pr_nodes="Y_65")
@


The cells are then ordered and assigned pseudotime values by the \code{order\_cells} function in \pkg{monocle3}.
The resulting pseudotime information can be visualized on the UMAP plot by using the \code{plot\_cells} function, as demonstrated in the UMAP plot on the right (Figure 7).
<<Figure7, fig.cap="UMAP visualization of pseudotime computed by monocle3. Cells are coloured by pseudotime.", fig.width=5*1.2, fig.height = 4*1.2, out.width="55%">>=
p2 <- plot_cells(cds_obj, color_cells_by="pseudotime",
                 label_groups_by_cluster=FALSE, label_leaves=FALSE,
                 label_branch_points=FALSE)
p2
@


The \code{pseudotime} function in \pkg{monocle3} allows users to extract the pseudotime values of the cells from a \code{cell\_data\_set} object. 
This information can then be stored in the metadata of the Seurat object for further analysis.
<<obtain pseudotime>>=
seurat_int$pseudotime <- pseudotime(cds_obj)
@


\section*{Pseudo-bulk time course analysis with edgeR}

\subsection*{Constructing pseudo-bulk profiles}

After obtaining the pseudotime of each cell, we proceed to a time course analysis to identify genes that change significantly along the pseudotime. Our approach involves creating pseudo-bulk samples using a pseudo-bulking approach and performing an \pkg{edgeR}-style time course analysis.\newline

To create the pseudo-bulk samples, read counts are aggregated for all cells with the same combination of sample and cluster. The number of cells used to construct each pseudo-bulk sample is added to the sample metadata. For simplicity, the average pseudotime of all cells in each pseudo-bulk sample is used as the pseudotime for that sample. One could also use the median of the cellwise pseudotime instead of the mean, but the results will not change dramatically.
<<prepare pseudobulk data, eval= eval_prepare_pseudobulk >>=
y <- dge_merged[, colnames(seurat_int)]
y$samples <- cbind(y$samples[, 1:3], 
  seurat_int@meta.data[, c("seurat_clusters", "pseudotime")])
sample_cluster <- paste0(y$samples$group, "_C", y$samples$seurat_clusters)
avg_pseudotime <- tapply(y$samples$pseudotime, sample_cluster, mean)
cell_number <- table(sample_cluster)
y <- sumTechReps(y, ID = sample_cluster)
y$samples$pseudotime <- avg_pseudotime[colnames(y)]
y$samples$cell_number <- cell_number[colnames(y)]
@

The Entrez gene IDs are added to the gene information. Genes with no valid Entrez gene IDs are removed from the downstream analysis.
<<obtain Entrez GeneID, eval= eval_prepare_pseudobulk>>=
library(org.Mm.eg.db)
entrez_id <- select(org.Mm.eg.db, keys = y$genes$Symbol,
              columns = c("ENTREZID", "SYMBOL"), keytype = "SYMBOL")
y$genes$ENTREZID <- entrez_id$ENTREZID
y <- y[!is.na(y$genes$ENTREZID), ]
@

The samples are ordered by average pseudotime for the following analysis.
<<order by pseudotime, eval= eval_prepare_pseudobulk>>=
y <- y[, order(y$samples$pseudotime)]
@

<<save pseudobulk, include=FALSE, eval= eval_prepare_pseudobulk, purl=FALSE>>=
filename_rds <- paste0(rds_res_dir,"/","dge_pseudobulk",".rds")
saveRDS(y, file = filename_rds)
@

<<read pseudobulk, include=FALSE, eval= !eval_prepare_pseudobulk, purl=FALSE>>=
filename_rds <- paste0(rds_res_dir,"/","dge_pseudobulk",".rds")
y <- readRDS(file = filename_rds)
@


\subsection*{Filtering and normalization}

We now proceed to the standard \pkg{edgeR} analysis pipeline, which starts with filtering and normalization.
The sample information, such as library sizes, average pseudotime and cell numbers, are shown below.
<<sample info pseudobulk>>=
y$samples[, c("lib.size", "pseudotime", "cell_number")]
@

To ensure the reliability of the analysis, it is recommended to remove pseudo-bulk samples that are constructed from a small number of cells. 
We suggest each pseudo-bulk sample should contain at least 30 cells.
In this analysis, we identified seven pseudo-bulk samples that were constructed with less than 30 cells and removed them form the analysis.
<<cell filtering pseudobulk>>=
keep_samples <- y$samples$cell_number > 30
y <- y[, keep_samples]
@

Genes with very low count number are also removed from the analysis.
This is performed by the \code{filterByExpr} function in \pkg{edgeR}.
<<gene filtering pseudobulk>>=
keep_genes <- filterByExpr(y)
y <- y[keep_genes, , keep.lib.sizes=FALSE]
@

The number of genes and samples after filtering are shown below.
<<dim after filtering pseudobulk>>=
dim(y)
@

Normalization is performed by the trimmed mean of M values (TMM) method \cite{robinson2010TMM} implemented in the \code{calcNormFactors} function in \pkg{edgeR}.
<<TMM normalization>>=
y <- calcNormFactors(y)
@

A Multi-dimensional scaling (MDS) plot serves as a valuable diagnostic tool for investigating the relationship among samples.
MDS plots are produced using the \code{plotMDS} function in \pkg{edgeR} (Figure 8).
<<Figure8, fig.cap="Multi-dimensional scaling (MDS) plot of the pseudo-bulk samples labelled by pseudotime. Samples are coloured by original cell cluster on the left and by developmental stage on the right.", fig.width = 11, fig.height = 5, out.width="100%">>=
par(mar = c(5.1, 5.1, 2.1, 2.1), mfrow=c(1,2))
cluster <- y$samples$seurat_clusters
group <- y$samples$group
plotMDS(y, labels = round(y$samples$pseudotime, 2),
    xlim=c(-6,4), ylim=c(-3,3), col=my_colors_15[cluster])
legend("topleft", legend=levels(cluster), col=my_colors_15, pch=16)
plotMDS(y, labels = round(y$samples$pseudotime, 2),
    xlim=c(-6,4), ylim=c(-3,3), col=my_colors_15[group])
legend("topleft", legend=levels(group), col=my_colors_15, pch=16)
@

On the MDS plot, pseudo-bulk samples derived from the same cell cluster are close to each other.
The samples are positioned in ascending order of pseudotime from left to right, suggesting a continuous shift in the gene expression profile throughout the pseudotime.

\subsection*{Design matrix}

The aim of a time course experiment is to examine the relationship between gene abundances and time points.
Assuming gene expression changes smoothly over time, we use a natural cubic spline with degrees of freedom of 3 to model gene expression along the pseudotime.
In general, any degrees of freedom in range of 3 to 5 is reasonable provided there are sufficient time points for the degrees of freedom of the residuals.\newline

The spline design matrix is generated by \code{ns} function in \pkg{splines}.
The three spline coefficients of the design matrix (i.e., Z1, Z2 and Z3) do not have any particular meaning in general.
However, we can re-parametrize the design matrix using QR decomposition so that the first coefficient Z1 represents the linear trend in pseudotime.
<<construct spline design matrix>>=
t1 <- y$samples$pseudotime
X <- splines::ns(as.numeric(t1),df = 3)
A <- cbind(1,t1,X)
QR <- qr(A)
r <- QR$rank
R_rank <- QR$qr[1:r,1:r]
Z <- t(backsolve(R_rank,t(A),transpose=TRUE))
Z <- Z[,-1]
@

Since the five samples are from different timepoints, the pseudo-bulk samples derived from these five samples are not independent replicates.
The sample effect at the pseudo-bulk level can also be seen from the MDS plot (Figure 8 right).
Hence, we add the sample effect to the design in addition to the re-parametrized spline coefficients.
The full design matrix is shown below.
<<construct spline design matrix 2>>=
group <- y$samples$group
design <- model.matrix(~ Z + group)
colnames(design) <- gsub("group", "", colnames(design))
design
@

\subsection*{Dispersion estimation}

The \pkg{edgeR} package uses negative binomial (NB) distribution to model read counts of each gene across all the samples.
The NB dispersions are estimated by the \code{estimateDisp} function.
The estimated common, trended and gene-specific dispersions can be visualized by \code{plotBCV} (Figure 9).
<<Figure9, fig.cap="A scatter plot of the biological coefficient of variation (BCV) against the average abundance of each gene in log2 count-per-million (CPM). The square-root estimates of the common, trended and gene-wise NB dispersions are shown.", fig.width = 5, fig.height = 4.5, out.width="55%">>=
y <- estimateDisp(y, design)
sqrt(y$common.dispersion)
plotBCV(y)
@

The NB model can be extended with quasi-likelihood (QL) methods to account for gene-specific variability from both biological and technical sources \cite{lund2012quasiseq, chen2016edgeR}.
Note that only the trended NB dispersion is used in the QL method. 
The gene-specific variability is captured by the QL dispersion, which is the dispersion parameter of the negative binomial QL generalized linear model.\newline

The \code{glmQLFit} function is used to fit a QL model and estimate QL dispersions.
The QL dispersion estimates can be visualized by \code{plotQLDisp} (Figure 10).
<<Figure10, fig.cap="A scatter plot of the quarter-root QL dispersion against the average abundance of each gene in log2 count-per-million (CPM). Estimates are shown for the raw, trended and squeezed dispersions.", fig.width=5, fig.height = 4.5, out.width="55%">>=
fit <- glmQLFit(y, design, robust=TRUE)
plotQLDisp(fit)
@

\subsection*{Time course trend analysis}

The QL F-tests are performed by \code{glmQLFTest} in \pkg{edgeR} to identify genes that change significantly along the pseudotime.
The tests are conducted on all three covariates of the spline model matrix.
This is because the significance of any of the three coefficients would indicate a strong correlation between gene expression and pseudotime.
<<F test>>=
res <- glmQLFTest(fit, coef=2:4)
@

The number of genes significantly associated with pseudotime (FDR < 0.05) are shown below.
<<DE gene number>>=
summary(decideTests(res))
@

Top significant genes can be viewed by \code{topTags}. 
<<all DE genes>>=
topTags(res, n=10L) 
@

The \code{logFC.Z1}, \code{logFC.Z2}, and \code{logFC.Z3} values in the table above denote the estimated coefficients of Z1, Z2, and Z3 for each gene.
It should be noted that these values do not carry the same interpretation as log-fold changes in traditional RNA-seq differential expression analysis.
For each gene, the sign of the coefficient \code{logFC.Z1} indicates whether the expression level of that gene increases or decreases along pseudotime in general.
The top increasing and the top decreasing genes are listed below.
<<top DE genes>>=
tab <- topTags(res, n=Inf)$table
tab$trend <- ifelse(tab$logFC.Z1 > 0, "Up", "Down")
tab.up <- tab[tab$trend == "Up", ]
tab.down <- tab[tab$trend == "Down", ]
head(tab.up)
head(tab.down)
@

Line graphs are produced to visualize the relationship between gene expression level and pseudotime for the top 6 increasing and the top 6 decreasing genes (Figure 11).
For each gene, the expression levels (in log2-CPM) are averaged across five samples, and the line is smoothed using its predicted expression level at 100 evenly spaced pseudotime points within the pseudotime range.
The smooth curves for the first 6 genes exhibit a generally increasing trend in gene expression over pseudotime, while the curves for the last 6 genes show a general decreasing trend.

<<Figure11, fig.cap="Line graphs of expression level of top genes along pseudotime. The red line represents the predicted expression level in log2-CPM along pseudotime.", fig.width = 3*3*0.8, fig.height = 3*4*0.8, out.width="90%">>=
design2 <- model.matrix(~ X + group)
fit2 <- glmQLFit(y, design2, robust=TRUE)
pt <- y$samples$pseudotime
pt_new <- round(seq(min(pt), max(pt), length.out=100), 2)
X_new <- predict(X, newx=pt_new)
topGenes <- c(rownames(tab.up)[1:6], rownames(tab.down)[1:6])
par(mfrow=c(4,3))
for(i in 1:12) {
  Symbol <- topGenes[i]
  beta <- coef(fit2)[Symbol,]
  AverageIntercept <- beta[1] + mean(c(0,beta[5:8]))
  Trend <- AverageIntercept + X_new %*% beta[2:4]
  Trend <- (Trend + log(1e6))/log(2)
  plot(pt_new, Trend,type="l", frame=FALSE, col="red", lwd=2,
       xlab="Pseudotime", ylab="Log2CPM", main=Symbol)
}
@

A heatmap is generated to examine the top 20 up and top 20 down genes collectively (Figure 12).
In the heatmap, pseudo-bulk samples are arranged in increasing pseudotime from left to right.
The up genes are on the top half of the heatmap whereas the down genes are on the bottom half.
The heatmap shows a gradual increase in expression levels of the up genes from left to right, while the down genes display the opposite trend.
<<Figure12, fig.cap="Heatmap of top 20 up and top 20 down genes. Rows are genes and columns are pseudo-bulk samples.", fig.width=6, fig.height = 8, out.width="60%">>=
logCPM.obs <- edgeR::cpm(y, log=TRUE, prior.count=fit$prior.count)
topGenes <- c(rownames(tab.up)[1:20], rownames(tab.down)[1:20])
z <- logCPM.obs[topGenes, ]
z <- t(scale(t(z)))
ComplexHeatmap::Heatmap(z, name = "Z score",
    cluster_rows = FALSE,cluster_columns = FALSE)
@

\section*{Time course functional enrichment analysis}

\subsection*{Gene ontology analysis}

To interpret the results of the time course analysis at the functional level, we perform gene set enrichment analysis. Gene ontology (GO) is one of the commonly used databases for this purpose. The GO terms in the GO databases are categorized into three classes: biological process (BP), cellular component (CC) and molecular function (MF). In a GO analysis, we are interested in finding GO terms that are over-represented or enriched with significant genes.\newline

GO analysis is usually directional. For simplicity, we re-perform the QL F-test on the \code{Z1} coefficient to identify genes that exhibit a general linear increase or decrease along pseudotime. The numbers of genes with a significant increasing or decreasing linear trend are shown below.
<<Test 2nd coefficient>>=
res_2 <- glmQLFTest(fit, coef=2)
summary(decideTests(res_2))
@ 

To perform a GO analysis, we apply the \code{goana} function to the above test results.
Note that Entrez gene IDs are required for \code{goana}, which has been added to the \code{ENTREZID} column in the gene annotation.
The top enriched GO terms can be viewed using \code{topGO} function.
<<goana>>=
go <- goana(res_2, geneid="ENTREZID", species="Mm")
topGO(go, truncate.term = 30, n=15)
@

It can be seen that most of the top GO terms are down-regulated.
Here, we choose the top 10 down-regulated terms for each GO category and show the results in a barplot (Figure 13).
<<Figure13, fig.cap="Barplot of $-\\log_{10}$ p-values of the top 10 down-regulated GO terms under each GO category.", fig.width=10, fig.height = 7.5, out.width="70%">>=
top_go <- rbind.data.frame(topGO(go, ont =c("BP"), sort="Down",n=10),
                           topGO(go, ont =c("CC"), sort="Down",n=10),
                           topGO(go, ont =c("MF"), sort="Down",n=10))
d <- transform(top_go, P_DE = P.Down, neg_log10_P = -log10(P.Down))
d$Term <- factor(d$Term,levels = d$Term)
ggplot(data = d, aes(x = neg_log10_P, y = Term, fill = Ont) ) +
  geom_bar(stat = "identity", show.legend = TRUE) + 
  labs(x="-log10 (P value)", y="", title = "Down") + 
  facet_grid(Ont~.,scales = "free",space = "free") + 
  my_theme_ggplot + my_theme_facet + 
  scale_fill_manual(values = my_colors_15[-2]) +
  theme(strip.text = ggplot2::element_blank())
@

\subsection*{KEGG pathway analysis}

The Kyoto Encyclopedia of Genes and Genomes \cite{kanehisa2000kegg} (KEGG) is another commonly used database for exploring signaling pathways to understand the molecular mechanism of diseases and biological processes.
A KEGG analysis can be done by using \code{kegga} function. \newline

The top enriched KEGG pathways can be viewed by using \code{topKEGG} function.
<<kegga>>=
kegg <- kegga(res_2, geneid="ENTREZID", species="Mm")
topKEGG(kegg, truncate.path=40, n=15)
@ 

The results show that most of the top enriched KEGG pathways are down-regulated.
Here, we select the top 15 down-regulated KEGG pathways and visualize their significance in a barplot (Figure 14).
<<Figure14, fig.cap="Barplot of $-\\log_{10}$ p-values of the top 15 down-regulated KEGG pathways.", fig.width=8, fig.height = 4.5, out.width="55%">>=
top_path <- topKEGG(kegg,sort="Down",n=15)
data_for_barplot <- transform(top_path, P_DE=P.Down, neg_log10_P=-log10(P.Down))
data_for_barplot$Pathway <- factor(data_for_barplot$Pathway,
                                   levels=data_for_barplot$Pathway)
ggplot(data=data_for_barplot,aes(x=neg_log10_P, y=Pathway) ) +
    geom_bar(stat="identity", show.legend=FALSE, fill=my_colors_15[1]) + 
    labs(x="-log10 (P value)", y="", title="Down" ) + 
    my_theme_ggplot 
@

Among the top down-regulated pathways, the PI3K-Akt signaling pathway is noteworthy as it is typically involved in cell proliferation and plays a crucial role in mammary gland development.\newline 

To assess the overall expression level of the PI3K-Akt signaling pathway across pseudotime, a plot is generated by plotting the average expression level of all the genes in the pathway against pseudotime.
The information of all the genes in the pathway can be obtained by \code{getGeneKEGGLinks} and \code{getKEGGPathwayNames}.
<<keggLinks>>=
kegg_links <- getGeneKEGGLinks("mmu") 
p_names <- getKEGGPathwayNames("mmu")
p1 <- p_names[grep("PI3K", p_names$Description), ] 
p1_GeneIDs <- subset(kegg_links, PathwayID == p1$PathwayID)$GeneID
tab_p1 <- tab[tab$ENTREZID %in% p1_GeneIDs, ]
d <- logCPM.obs[tab_p1$Symbol,]
d <- apply(d, 2, mean)
d <- data.frame(avg_logCPM = d, avg_pseudotime = y$samples$pseudotime)
head(d)
@

The plot below clearly illustrates a significant down-regulation of the PI3K-Akt pathway along pseudotime (Figure 15).
<<Figure15, fig.cap="A smooth curve of PI3K-Akt signaling pathway expression level against pseudotime.", fig.width = 6.5, fig.height = 5, out.width="50%">>=
ggplot(data = d,aes(x = avg_pseudotime, y = avg_logCPM) ) +
    geom_smooth(color=my_colors_15[1],se = FALSE) + 
    labs(x="Pseudotime", y="Average log-CPM", 
         title = "PI3K-Akt signaling pathway" ) + 
    my_theme_ggplot 
@

\section*{Discussion}

In this article, we demonstrated a complete workflow of a pseudo-temporal trajectory analysis of scRNA-seq data.
This workflow takes single-cell count matrices as input and leverages the Seurat pipeline for standard scRNA-seq analysis, including quality control, normalization, and integration.
The \pkg{scDblFinder} package is utilized for doublet prediction. 
Trajectory inference is conducted with \pkg{monocle3}, while the \pkg{edgeR} QL framework with a pseudo-bulking strategy is applied for pseudo-time course analysis.
Alternative methods and packages can be used interchangeably with the ones implemented in this study, as long as they perform equivalent functions.
For instance, the bioconductor workflow may be substituted for the Seurat pipeline in scRNA-seq analysis, whereas the \pkg{slingshot} package may replace \pkg{monocle3} for performing trajectory analysis.\newline

This workflow article utilized 10x scRNA-seq data from five distinct stages of mouse mammary gland development, with a focus on the lineage progression of epithelial cells.
By performing a time course analysis based on pseudotime along the developmental trajectory, we successfully identified genes and pathways that exhibit differential expression patterns over the course of pseudotime.
The results of this extensive analysis not only confirm previous findings in the literature regarding the mouse mammary gland epithelium, but also reveal genes and pathways that exhibit continuous changes along the epithelial lineage.
The analytical framework presented here can be utilized for any single-cell experiments aimed at studying dynamic changes along a specific path, whether it involves cell differentiation or the development of cell types.


\section*{Packages used}

This workflow depends on various packages from the Bioconductor project version 3.15, the Comprehensive R Archive Network (CRAN) and GitHub, running on R version 4.2.1 or higher.
The complete list of the packages used for this workflow are shown below:
<<sessionInfo, eval=TRUE>>=
sessionInfo()
@


% save rdata, delete this code chunk after done
<<save rdata, include=FALSE, eval=eval_save_rdata, purl=FALSE>>=
save.image(file = "time_course_analysis.rdata")
@


\section*{Data availability} % Required

\subsection*{Underlying data}

The single-cell RNA-seq datasets used in this study were obtained from the Gene Expression Omnibus (GEO) with accession numbers of \href{https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE103275}{GSE103275} \cite{pal2017mouse} and \href{https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE164017}{GSE164017} \cite{pal2021mouse}.

\section*{Software availability}

Source code available from: \url{https://github.com/jinming-cheng/TimeCoursePaperWorkflow}\\
Archived source code at time of publication: \url{https://doi.org/10.5281/zenodo.7879833} \cite{cheng2023zenodo}\\
License: \href{https://opensource.org/license/gpl-3-0/}{GNU General Public License version 3} (GPL-3.0-only)\\

All the packages used in this workflow are publicly available from the \href{https://www.bioconductor.org/}{Bioconductor} project (version 3.15), the Comprehensive R Archive Network (\href{https://cran.r-project.org/}{CRAN}) and \href{https://github.com/}{GitHub}.


{\small\bibliographystyle{unsrtnat}
\bibliography{ref}}
 

% See this guide for more information on BibTeX:
% http://libguides.mit.edu/content.php?pid=55482&sid=406343

% Please note that this template results in a draft pre-submission PDF document.
% Articles will be professionally typeset when accepted for publication.

% We hope you find the F1000Research LaTex template useful, please contact us if you have any feedback.

\end{document}
